# Makefile.multi-env - Comandos que funcionan en mÃºltiples ambientes
# Usar: make [comando] ENV=[development|production]

# Cargar configuraciÃ³n segÃºn el ambiente
ENV ?= development
include .make.env

# ConfiguraciÃ³n segÃºn ambiente
ifeq ($(ENV),production)
    HOST := $(NAS_HOST)
    USER := $(NAS_USER)
    DB_NAME := ai_service
    DB_USER := ai_user
    CONTAINER := ai-postgres
    API_URL := http://$(HOST):3003
    SSH_PREFIX := sshpass -e ssh $(USER)@$(HOST)
    SUDO_PREFIX := echo '$(SUDO_PASS)' | sudo -S
    DOCKER_CMD := $(SUDO_PREFIX) /usr/local/bin/docker
else
    HOST := localhost
    USER := $(shell whoami)
    DB_NAME := ai_service
    DB_USER := postgres
    CONTAINER := ai-service-postgres-1
    API_URL := http://localhost:3000
    SSH_PREFIX := 
    SUDO_PREFIX := 
    DOCKER_CMD := docker
endif

# Colores
CYAN := \033[0;36m
GREEN := \033[0;32m
YELLOW := \033[0;33m
RED := \033[0;31m
NC := \033[0m

# =============================================================================
# ğŸ”µ COMANDOS MULTI-AMBIENTE
# =============================================================================

.PHONY: env-info
env-info: ## Mostrar informaciÃ³n del ambiente actual
	@echo "$(CYAN)ğŸ“ Ambiente: $(ENV)$(NC)"
	@echo "Host: $(HOST)"
	@echo "Usuario: $(USER)"
	@echo "Base de datos: $(DB_NAME)"
	@echo "API URL: $(API_URL)"

.PHONY: status
status: ## Estado del ambiente (ENV=development|production)
	@echo "$(CYAN)ğŸ“Š Estado de $(ENV)$(NC)"
	@echo "$(YELLOW)â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”$(NC)"
	@curl -s $(API_URL)/status | python3 -m json.tool || echo "$(RED)âœ— Servicio no disponible$(NC)"

.PHONY: check-db
check-db: ## Verificar base de datos en cualquier ambiente
	@echo "$(CYAN)ğŸ—„ï¸  Verificando BD en $(ENV)...$(NC)"
ifeq ($(ENV),production)
	@$(SSH_PREFIX) "$(DOCKER_CMD) exec $(CONTAINER) pg_isready -U $(DB_USER) -d $(DB_NAME)"
else
	@$(DOCKER_CMD) exec $(CONTAINER) pg_isready -U $(DB_USER) -d $(DB_NAME)
endif

.PHONY: apply-sql
apply-sql: ## Aplicar archivo SQL (make apply-sql FILE=path/to/file.sql ENV=production)
	@if [ -z "$(FILE)" ]; then \
		echo "$(RED)Error: Especifica el archivo con FILE=path/to/file.sql$(NC)"; \
		exit 1; \
	fi
	@echo "$(CYAN)ğŸ“ Aplicando $(FILE) en $(ENV)...$(NC)"
ifeq ($(ENV),production)
	@$(MAKE) prod-apply-sql FILE=$(FILE) -f Makefile.production
else
	@docker exec -i $(CONTAINER) psql -U $(DB_USER) -d $(DB_NAME) < $(FILE)
endif
	@echo "$(GREEN)âœ“ SQL aplicado$(NC)"

.PHONY: backup
backup: ## Crear backup en cualquier ambiente
	@echo "$(CYAN)ğŸ’¾ Creando backup de $(ENV)...$(NC)"
	@TIMESTAMP=$$(date +%Y%m%d_%H%M%S); \
	if [ "$(ENV)" = "production" ]; then \
		$(MAKE) prod-backup -f Makefile.production; \
	else \
		mkdir -p backups; \
		$(DOCKER_CMD) exec $(CONTAINER) pg_dump -U $(DB_USER) -d $(DB_NAME) | gzip > backups/backup_dev_$$TIMESTAMP.sql.gz; \
		echo "$(GREEN)âœ“ Backup creado: backups/backup_dev_$$TIMESTAMP.sql.gz$(NC)"; \
	fi

.PHONY: logs
logs: ## Ver logs del servicio en cualquier ambiente
	@echo "$(CYAN)ğŸ“‹ Logs de $(ENV)$(NC)"
ifeq ($(ENV),production)
	@$(SSH_PREFIX) "$(DOCKER_CMD) logs --tail 50 -f ai-service"
else
	@$(DOCKER_CMD) logs --tail 50 -f ai-service-ai-service-1
endif

.PHONY: restart
restart: ## Reiniciar servicios en cualquier ambiente
	@echo "$(CYAN)ğŸ”„ Reiniciando servicios en $(ENV)...$(NC)"
ifeq ($(ENV),production)
	@echo "$(YELLOW)âš ï¸  Reiniciando PRODUCCIÃ“N. Â¿Continuar? (s/N):$(NC)"
	@read CONFIRM && [ "$$CONFIRM" = "s" ] || (echo "$(GREEN)Cancelado$(NC)" && exit 1)
	@$(SSH_PREFIX) "$(DOCKER_CMD) restart ai-service"
else
	@docker-compose restart
endif
	@echo "$(GREEN)âœ“ Servicios reiniciados$(NC)"

.PHONY: db-shell
db-shell: ## Abrir shell PostgreSQL en cualquier ambiente
	@echo "$(CYAN)ğŸ˜ Conectando a PostgreSQL en $(ENV)...$(NC)"
ifeq ($(ENV),production)
	@$(SSH_PREFIX) -t "$(DOCKER_CMD) exec -it $(CONTAINER) psql -U $(DB_USER) -d $(DB_NAME)"
else
	@$(DOCKER_CMD) exec -it $(CONTAINER) psql -U $(DB_USER) -d $(DB_NAME)
endif

.PHONY: exec
exec: ## Ejecutar comando en contenedor (make exec CMD="ls -la" ENV=production)
	@if [ -z "$(CMD)" ]; then \
		echo "$(RED)Error: Especifica el comando con CMD=\"comando\"$(NC)"; \
		exit 1; \
	fi
	@echo "$(CYAN)ğŸ”§ Ejecutando en $(ENV): $(CMD)$(NC)"
ifeq ($(ENV),production)
	@$(SSH_PREFIX) "$(DOCKER_CMD) exec ai-service $(CMD)"
else
	@$(DOCKER_CMD) exec ai-service-ai-service-1 $(CMD)
endif

.PHONY: health
health: ## Health check detallado en cualquier ambiente
	@echo "$(CYAN)ğŸ¥ Health Check de $(ENV)$(NC)"
	@echo "$(YELLOW)â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”$(NC)"
	@STATUS=$$(curl -s $(API_URL)/status | python3 -c "import sys, json; print(json.load(sys.stdin).get('status', 'unknown'))" 2>/dev/null || echo "error"); \
	if [ "$$STATUS" = "healthy" ]; then \
		echo "API Status: $(GREEN)âœ“ $$STATUS$(NC)"; \
	elif [ "$$STATUS" = "degraded" ]; then \
		echo "API Status: $(YELLOW)âš  $$STATUS$(NC)"; \
	else \
		echo "API Status: $(RED)âœ— $$STATUS$(NC)"; \
	fi
	@echo -n "Database: "
	@if $(MAKE) check-db ENV=$(ENV) --no-print-directory >/dev/null 2>&1; then \
		echo "$(GREEN)âœ“ Conectado$(NC)"; \
	else \
		echo "$(RED)âœ— Sin conexiÃ³n$(NC)"; \
	fi

.PHONY: validate-env
validate-env: ## Validar configuraciÃ³n del ambiente
	@echo "$(CYAN)ğŸ” Validando ambiente $(ENV)...$(NC)"
	@if [ "$(ENV)" != "development" ] && [ "$(ENV)" != "production" ]; then \
		echo "$(RED)Error: ENV debe ser 'development' o 'production'$(NC)"; \
		exit 1; \
	fi
	@if [ "$(ENV)" = "production" ] && [ -z "$(SSHPASS)" ]; then \
		echo "$(RED)Error: SSHPASS no estÃ¡ configurado para producciÃ³n$(NC)"; \
		echo "Configura las credenciales en .make.env"; \
		exit 1; \
	fi
	@echo "$(GREEN)âœ“ Ambiente vÃ¡lido$(NC)"

# =============================================================================
# Ayuda
# =============================================================================

.PHONY: help
help: ## Mostrar esta ayuda
	@echo "$(CYAN)â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—$(NC)"
	@echo "$(CYAN)â•‘              COMANDOS MULTI-AMBIENTE                          â•‘$(NC)"
	@echo "$(CYAN)â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•$(NC)"
	@echo ""
	@echo "Uso: make [comando] ENV=[development|production]"
	@echo "Ambiente actual: $(ENV)"
	@echo ""
	@grep -E '^[a-zA-Z_-]+:.*?## .*$$' $(MAKEFILE_LIST) | awk 'BEGIN {FS = ":.*?## "}; {printf "$(CYAN)%-20s$(NC) %s\n", $$1, $$2}'
	@echo ""
	@echo "Ejemplos:"
	@echo "  make status ENV=production"
	@echo "  make apply-sql FILE=migration.sql ENV=development"
	@echo "  make backup ENV=production"

.DEFAULT_GOAL := help