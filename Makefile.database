# Makefile.database - Database operations module
# =============================================================================
# Database management, migrations, backups, and SQL operations
# =============================================================================

# Load configuration
-include .make.env

# Variables
NAS_HOST ?= 192.168.1.11
NAS_USER ?= admin
NAS_PATH ?= /volume1/docker/ai-service
DB_NAME ?= ai_service
DB_USER ?= ai_user
CONTAINER_NAME ?= ai-postgres
BACKUP_DIR ?= ./backups
TIMESTAMP := $(shell date +%Y%m%d_%H%M%S)

# SSH configuration
ifdef SSHPASS
    SSH_CMD := sshpass -e ssh
    SCP_CMD := sshpass -e scp
else
    SSH_CMD := ssh
    SCP_CMD := scp
endif

# Colors
RED := \033[0;31m
GREEN := \033[0;32m
YELLOW := \033[0;33m
BLUE := \033[0;34m
NC := \033[0m

# =============================================================================
# üóÑÔ∏è DATABASE BASIC OPERATIONS
# =============================================================================

.PHONY: db-shell
db-shell: ## Open PostgreSQL shell (psql) - interactive database access
	@echo "$(BLUE)Connecting to database...$(NC)"
	@docker exec -it $(CONTAINER_NAME) psql -U $(DB_USER) -d $(DB_NAME)

.PHONY: db-studio
db-studio: ## Open Prisma Studio - visual database browser
	@echo "$(BLUE)Starting Prisma Studio...$(NC)"
	@echo "$(YELLOW)Opening at http://localhost:5555$(NC)"
	@npx prisma studio

.PHONY: db-tables
db-tables: ## List all database tables with row counts
	@echo "$(BLUE)Database Tables:$(NC)"
	@docker exec $(CONTAINER_NAME) psql -U $(DB_USER) -d $(DB_NAME) -c "\
		SELECT schemaname, tablename, \
		       (SELECT COUNT(*) FROM \"\$${schemaname}\".\"\$${tablename}\") as row_count \
		FROM pg_tables \
		WHERE schemaname NOT IN ('pg_catalog', 'information_schema') \
		ORDER BY schemaname, tablename;"

.PHONY: db-info
db-info: ## Show database size and connection info
	@echo "$(BLUE)Database Information:$(NC)"
	@docker exec $(CONTAINER_NAME) psql -U $(DB_USER) -d $(DB_NAME) -c "\
		SELECT pg_database_size('$(DB_NAME)')/1024/1024 as size_mb, \
		       current_database() as database, \
		       current_user as user, \
		       version() as postgres_version;"

# =============================================================================
# üîÑ PRISMA OPERATIONS
# =============================================================================

.PHONY: db-generate
db-generate: ## Generate Prisma client from schema
	@echo "$(BLUE)Generating Prisma client...$(NC)"
	@npx prisma generate
	@echo "$(GREEN)‚úì Prisma client generated$(NC)"

.PHONY: db-push
db-push: ## Push Prisma schema to database (development only!)
	@echo "$(YELLOW)‚ö†Ô∏è  WARNING: This will overwrite database schema!$(NC)"
	@read -p "Are you sure? (y/N): " confirm && [ "$$confirm" = "y" ] || exit 1
	@npx prisma db push
	@echo "$(GREEN)‚úì Schema pushed to database$(NC)"

.PHONY: db-seed
db-seed: ## Seed database with initial data
	@echo "$(BLUE)Seeding database...$(NC)"
	@npx prisma db seed
	@echo "$(GREEN)‚úì Database seeded$(NC)"

.PHONY: db-format
db-format: ## Format Prisma schema file
	@echo "$(BLUE)Formatting Prisma schema...$(NC)"
	@npx prisma format
	@echo "$(GREEN)‚úì Schema formatted$(NC)"

# =============================================================================
# üöÄ MIGRATIONS
# =============================================================================

.PHONY: db-migrate
db-migrate: ## Apply pending migrations
	@echo "$(BLUE)Applying migrations...$(NC)"
	@npx prisma migrate deploy
	@echo "$(GREEN)‚úì Migrations applied$(NC)"

.PHONY: db-migrate-status
db-migrate-status: ## Check migration status
	@echo "$(BLUE)Migration Status:$(NC)"
	@npx prisma migrate status

.PHONY: db-migrate-create
db-migrate-create: ## Create new migration (use: make db-migrate-create NAME=add_users_table)
	@if [ -z "$(NAME)" ]; then \
		echo "$(RED)Error: NAME is required$(NC)"; \
		echo "Usage: make db-migrate-create NAME=description"; \
		exit 1; \
	fi
	@echo "$(BLUE)Creating migration: $(NAME)$(NC)"
	@npx prisma migrate dev --name $(NAME) --create-only
	@echo "$(GREEN)‚úì Migration created$(NC)"
	@echo "$(YELLOW)Review the migration file, then run 'make db-migrate' to apply$(NC)"

.PHONY: db-migrate-deploy
db-migrate-deploy: ## Deploy migrations to production
	@echo "$(YELLOW)‚ö†Ô∏è  Deploying to PRODUCTION database$(NC)"
	@read -p "Are you sure? (y/N): " confirm && [ "$$confirm" = "y" ] || exit 1
	@DATABASE_URL="$${DATABASE_URL_PROD}" npx prisma migrate deploy
	@echo "$(GREEN)‚úì Migrations deployed to production$(NC)"

.PHONY: db-migrate-reset
db-migrate-reset: ## Reset database and reapply all migrations (DESTRUCTIVE!)
	@echo "$(RED)‚ö†Ô∏è  WARNING: This will DELETE ALL DATA!$(NC)"
	@read -p "Type 'DELETE ALL' to confirm: " confirm && [ "$$confirm" = "DELETE ALL" ] || exit 1
	@npx prisma migrate reset --force
	@echo "$(GREEN)‚úì Database reset complete$(NC)"

# =============================================================================
# üíæ BACKUP & RESTORE
# =============================================================================

.PHONY: db-backup
db-backup: ## Create database backup
	@echo "$(BLUE)Creating database backup...$(NC)"
	@mkdir -p $(BACKUP_DIR)
	@docker exec $(CONTAINER_NAME) pg_dump -U $(DB_USER) -d $(DB_NAME) \
		--no-owner --no-acl --clean --if-exists \
		> $(BACKUP_DIR)/backup_$(TIMESTAMP).sql
	@echo "$(GREEN)‚úì Backup saved to: $(BACKUP_DIR)/backup_$(TIMESTAMP).sql$(NC)"
	@ls -lh $(BACKUP_DIR)/backup_$(TIMESTAMP).sql

.PHONY: db-backup-prod
db-backup-prod: ## Backup production database
	@echo "$(BLUE)Backing up PRODUCTION database...$(NC)"
	@mkdir -p $(BACKUP_DIR)/production
	@$(SSH_CMD) $(NAS_USER)@$(NAS_HOST) \
		"docker exec $(CONTAINER_NAME) pg_dump -U $(DB_USER) -d $(DB_NAME) \
		--no-owner --no-acl --clean --if-exists" \
		> $(BACKUP_DIR)/production/backup_prod_$(TIMESTAMP).sql
	@echo "$(GREEN)‚úì Production backup saved to: $(BACKUP_DIR)/production/backup_prod_$(TIMESTAMP).sql$(NC)"

.PHONY: db-restore
db-restore: ## Restore database from backup (use: make db-restore FILE=backups/backup_20250101_120000.sql)
	@if [ -z "$(FILE)" ]; then \
		echo "$(RED)Error: FILE is required$(NC)"; \
		echo "Usage: make db-restore FILE=path/to/backup.sql"; \
		echo ""; \
		echo "Available backups:"; \
		ls -1t $(BACKUP_DIR)/*.sql 2>/dev/null | head -10 || echo "No backups found"; \
		exit 1; \
	fi
	@echo "$(YELLOW)‚ö†Ô∏è  WARNING: This will replace current database!$(NC)"
	@read -p "Restore from $(FILE)? (y/N): " confirm && [ "$$confirm" = "y" ] || exit 1
	@echo "$(BLUE)Restoring database...$(NC)"
	@docker exec -i $(CONTAINER_NAME) psql -U $(DB_USER) -d $(DB_NAME) < $(FILE)
	@echo "$(GREEN)‚úì Database restored from: $(FILE)$(NC)"

.PHONY: db-backup-list
db-backup-list: ## List available backups
	@echo "$(BLUE)Available Backups:$(NC)"
	@echo "$(YELLOW)Local:$(NC)"
	@ls -1t $(BACKUP_DIR)/*.sql 2>/dev/null | head -10 || echo "  No local backups found"
	@echo ""
	@echo "$(YELLOW)Production:$(NC)"
	@ls -1t $(BACKUP_DIR)/production/*.sql 2>/dev/null | head -10 || echo "  No production backups found"

# =============================================================================
# üîê PASSWORD MANAGEMENT
# =============================================================================

.PHONY: db-password-change
db-password-change: ## Change database password (interactive)
	@echo "$(BLUE)Database Password Change Wizard$(NC)"
	@echo "$(YELLOW)Select environment:$(NC)"
	@echo "  1) Development"
	@echo "  2) Production"
	@read -p "Choice (1-2): " ENV_CHOICE; \
	case $$ENV_CHOICE in \
		1) $(MAKE) -f Makefile.database db-password-dev ;; \
		2) $(MAKE) -f Makefile.database db-password-prod ;; \
		*) echo "$(RED)Invalid choice$(NC)"; exit 1 ;; \
	esac

.PHONY: db-password-dev
db-password-dev: ## Change development database password
	@echo "$(YELLOW)Changing development database password...$(NC)"
	@read -s -p "Enter new password: " NEW_PASS; echo ""; \
	read -s -p "Confirm password: " CONFIRM_PASS; echo ""; \
	if [ "$$NEW_PASS" != "$$CONFIRM_PASS" ]; then \
		echo "$(RED)Passwords don't match!$(NC)"; \
		exit 1; \
	fi; \
	docker exec $(CONTAINER_NAME) psql -U postgres -c "ALTER USER $(DB_USER) PASSWORD '$$NEW_PASS';" && \
	echo "$(GREEN)‚úì Password changed successfully$(NC)" && \
	echo "$(YELLOW)Don't forget to update .env file!$(NC)"

.PHONY: db-password-prod
db-password-prod: ## Change production database password
	@echo "$(RED)‚ö†Ô∏è  CHANGING PRODUCTION PASSWORD$(NC)"
	@echo "$(YELLOW)This requires updating all services!$(NC)"
	@read -p "Continue? (y/N): " confirm && [ "$$confirm" = "y" ] || exit 1
	@read -s -p "Enter new password: " NEW_PASS; echo ""; \
	read -s -p "Confirm password: " CONFIRM_PASS; echo ""; \
	if [ "$$NEW_PASS" != "$$CONFIRM_PASS" ]; then \
		echo "$(RED)Passwords don't match!$(NC)"; \
		exit 1; \
	fi; \
	$(SSH_CMD) $(NAS_USER)@$(NAS_HOST) \
		"docker exec $(CONTAINER_NAME) psql -U postgres -c \"ALTER USER $(DB_USER) PASSWORD '$$NEW_PASS';\"" && \
	echo "$(GREEN)‚úì Production password changed$(NC)" && \
	echo "$(RED)IMPORTANT: Update production .env file immediately!$(NC)"

# =============================================================================
# üîç SQL OPERATIONS
# =============================================================================

.PHONY: db-sql
db-sql: ## Execute SQL query (use: make db-sql SQL="SELECT * FROM users LIMIT 5")
	@if [ -z "$(SQL)" ]; then \
		echo "$(RED)Error: SQL is required$(NC)"; \
		echo "Usage: make db-sql SQL=\"your query here\""; \
		exit 1; \
	fi
	@docker exec $(CONTAINER_NAME) psql -U $(DB_USER) -d $(DB_NAME) -c "$(SQL)"

.PHONY: db-sql-file
db-sql-file: ## Execute SQL file (use: make db-sql-file FILE=script.sql)
	@if [ -z "$(FILE)" ]; then \
		echo "$(RED)Error: FILE is required$(NC)"; \
		echo "Usage: make db-sql-file FILE=path/to/script.sql"; \
		exit 1; \
	fi
	@echo "$(BLUE)Executing SQL file: $(FILE)$(NC)"
	@docker exec -i $(CONTAINER_NAME) psql -U $(DB_USER) -d $(DB_NAME) < $(FILE)
	@echo "$(GREEN)‚úì SQL file executed$(NC)"

# =============================================================================
# üè• DATABASE HEALTH & DIAGNOSTICS
# =============================================================================

.PHONY: db-health
db-health: ## Check database health and statistics
	@echo "$(BLUE)Database Health Check:$(NC)"
	@docker exec $(CONTAINER_NAME) psql -U $(DB_USER) -d $(DB_NAME) -c "\
		SELECT 'Connections' as metric, count(*) as value \
		FROM pg_stat_activity \
		UNION ALL \
		SELECT 'Database Size (MB)', pg_database_size('$(DB_NAME)')/1024/1024 \
		UNION ALL \
		SELECT 'Tables', count(*) FROM information_schema.tables \
		WHERE table_schema NOT IN ('pg_catalog', 'information_schema') \
		UNION ALL \
		SELECT 'Indexes', count(*) FROM pg_indexes \
		WHERE schemaname NOT IN ('pg_catalog', 'information_schema');"

.PHONY: db-locks
db-locks: ## Show database locks
	@echo "$(BLUE)Active Database Locks:$(NC)"
	@docker exec $(CONTAINER_NAME) psql -U $(DB_USER) -d $(DB_NAME) -c "\
		SELECT pid, usename, application_name, client_addr, \
		       backend_start, state, wait_event_type, wait_event, query \
		FROM pg_stat_activity \
		WHERE state != 'idle' \
		ORDER BY backend_start;"

.PHONY: db-vacuum
db-vacuum: ## Run VACUUM ANALYZE on all tables
	@echo "$(BLUE)Running VACUUM ANALYZE...$(NC)"
	@docker exec $(CONTAINER_NAME) psql -U $(DB_USER) -d $(DB_NAME) -c "VACUUM ANALYZE;"
	@echo "$(GREEN)‚úì VACUUM ANALYZE complete$(NC)"

# =============================================================================
# üìò HELP
# =============================================================================

.PHONY: help
help: ## Show this help message
	@echo "$(BLUE)Database Management Commands:$(NC)"
	@echo ""
	@grep -E '^[a-zA-Z0-9_-]+:.*?## .*$$' $(MAKEFILE_LIST) | \
		awk 'BEGIN {FS = ":.*?## "}; {printf "  $(GREEN)%-20s$(NC) %s\n", $$1, $$2}' | \
		sort