"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const node_fs_1 = require("node:fs");
const node_path_1 = __importDefault(require("node:path"));
const node_child_process_1 = require("node:child_process");
const node_util_1 = require("node:util");
const execFileAsync = (0, node_util_1.promisify)(node_child_process_1.execFile);
async function main() {
    var _a;
    const repoRoot = node_path_1.default.resolve(__dirname, '../../..');
    const openapiDir = node_path_1.default.join(repoRoot, 'openapi');
    const outDir = node_path_1.default.join(__dirname, 'generated');
    await node_fs_1.promises.mkdir(outDir, { recursive: true });
    const entries = await node_fs_1.promises.readdir(openapiDir, { withFileTypes: true }).catch(() => []);
    const specs = entries
        .filter((e) => e.isFile())
        .map((e) => e.name)
        .filter((n) => /\.(ya?ml|json)$/i.test(n));
    if (specs.length === 0) {
        console.warn(`No OpenAPI specs found in ${openapiDir}`);
    }
    const generated = [];
    // Resolve CLI entry for openapi-typescript within workspace root
    const pkgJsonPath = require.resolve('openapi-typescript/package.json', { paths: [repoRoot] });
    const pkgDir = node_path_1.default.dirname(pkgJsonPath);
    const pkgJson = JSON.parse(await node_fs_1.promises.readFile(pkgJsonPath, 'utf8'));
    const binRel = ((_a = pkgJson.bin) === null || _a === void 0 ? void 0 : _a['openapi-typescript']) || 'bin/cli.mjs';
    const cli = node_path_1.default.join(pkgDir, binRel);
    for (const file of specs) {
        const base = node_path_1.default.basename(file).replace(/\.(ya?ml|json)$/i, '');
        const specPath = node_path_1.default.join(openapiDir, file);
        const outFile = node_path_1.default.join(outDir, `${base}.ts`);
        // Run CLI to generate types directly to file
        await execFileAsync(process.execPath, [cli, specPath, '--output', outFile], {
            cwd: repoRoot,
            env: process.env,
        });
        // Prepend header (read+rewrite for simplicity)
        const current = await node_fs_1.promises.readFile(outFile, 'utf8');
        await node_fs_1.promises.writeFile(outFile, `// AUTO-GENERATED by @ai/contracts. Do not edit.\n${current}`, 'utf8');
        generated.push(base);
        console.log(`Generated types for ${file} -> ${node_path_1.default.relative(repoRoot, outFile)}`);
    }
    // Create a barrel that re-exports types and exposes a typed client factory
    const indexLines = [];
    indexLines.push(`import createClient from 'openapi-fetch';`);
    indexLines.push(`export { createClient };`);
    for (const base of generated) {
        const typeName = `${pascal(base)}Paths`;
        indexLines.push(`import type { paths as ${typeName} } from './generated/${base}';`);
        indexLines.push(`export type { paths as ${typeName} } from './generated/${base}';`);
        indexLines.push(`export const create${pascal(base)}Client = (baseUrl: string) => createClient<${typeName}>({ baseUrl });`);
    }
    indexLines.push('');
    const indexPath = node_path_1.default.join(__dirname, 'index.ts');
    await node_fs_1.promises.writeFile(indexPath, indexLines.join('\n'), 'utf8');
    console.log(`Wrote barrel: ${node_path_1.default.relative(repoRoot, indexPath)}`);
}
function pascal(input) {
    return input
        .replace(/[^a-zA-Z0-9]+/g, ' ')
        .split(' ')
        .filter(Boolean)
        .map((s) => s[0].toUpperCase() + s.slice(1))
        .join('');
}
main().catch((err) => {
    console.error(err);
    process.exit(1);
});
