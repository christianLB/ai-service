# Makefile.production - Comandos especÃ­ficos para producciÃ³n
# ADVERTENCIA: Estos comandos afectan PRODUCCIÃ“N. Usar con cuidado.

include .make.env

# Export variables for SSH authentication
export SSHPASS
export SUDO_PASS

# Variables de producciÃ³n
PROD_HOST := 192.168.1.11
PROD_USER := k2600x
PROD_PATH := /volume1/docker/ai-service
PROD_DB := ai_service
PROD_DB_USER := ai_user
PROD_CONTAINER := ai-postgres
BACKUP_DIR := $(PROD_PATH)/backups

# SSH con clave SSH (sin contraseÃ±a)
SSH := ssh
SCP := scp

# Colores
RED := \033[0;31m
GREEN := \033[0;32m
YELLOW := \033[0;33m
BLUE := \033[0;34m
NC := \033[0m

# =============================================================================
# ğŸ”§ COMANDOS DE SQL DIRECTO
# =============================================================================

.PHONY: prod-sql
prod-sql: ## Ejecutar SQL directo en producciÃ³n (usar: make prod-sql SQL="SELECT 1")
	@if [ -z "$(SQL)" ]; then \
		echo "$(RED)Error: Especifica SQL=\"tu consulta SQL\"$(NC)"; \
		exit 1; \
	fi
	@echo "$(BLUE)Ejecutando SQL en producciÃ³n...$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker exec ai-postgres psql -U $(PROD_DB_USER) -d $(PROD_DB) -c \"$(SQL)\""

.PHONY: prod-sql-file
prod-sql-file: ## Ejecutar archivo SQL en producciÃ³n (usar: make prod-sql-file FILE=script.sql)
	@if [ -z "$(FILE)" ]; then \
		echo "$(RED)Error: Especifica FILE=ruta/al/archivo.sql$(NC)"; \
		exit 1; \
	fi
	@echo "$(BLUE)Ejecutando archivo SQL: $(FILE)$(NC)"
	@cat $(FILE) | $(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker exec -i ai-postgres psql -U $(PROD_DB_USER) -d $(PROD_DB)"

# =============================================================================
# ğŸ”´ COMANDOS DE PRODUCCIÃ“N - Reset y Recovery
# =============================================================================

.PHONY: prod-reset-db
prod-reset-db: ## Reset completo de BD en PRODUCCIÃ“N (con confirmaciÃ³n)
	@echo "$(RED)âš ï¸  ADVERTENCIA: Esto ELIMINARÃ TODOS LOS DATOS en PRODUCCIÃ“N$(NC)"
	@echo "$(RED)Host: $(PROD_HOST)$(NC)"
	@echo "$(RED)Base de datos: $(PROD_DB)$(NC)"
	@echo "$(YELLOW)Â¿EstÃ¡s ABSOLUTAMENTE SEGURO? Escribe 'SI ELIMINAR TODO' para continuar:$(NC)"
	@read CONFIRM && [ "$$CONFIRM" = "SI ELIMINAR TODO" ] || (echo "$(GREEN)Cancelado$(NC)" && exit 1)
	@$(MAKE) prod-backup
	@echo "$(YELLOW)Ejecutando reset...$(NC)"
	@$(MAKE) prod-reset-db-force

.PHONY: prod-reset-db-force
prod-reset-db-force: ## Reset sin confirmaciÃ³n (solo para emergencias)
	@echo "$(RED)ğŸ”¥ RESET FORZADO EN PRODUCCIÃ“N$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker stop ai-service ai-postgres ai-redis || true"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo rm -rf $(PROD_PATH)/postgres-data/*"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker start ai-postgres"
	@sleep 10
	@$(MAKE) prod-create-db
	@$(MAKE) prod-apply-schema
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker start ai-redis ai-service"
	@sleep 10
	@$(MAKE) prod-health

.PHONY: prod-create-db
prod-create-db: ## Crear base de datos en producciÃ³n si no existe
	@echo "$(BLUE)ğŸ“Š Creando base de datos si no existe...$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker exec $(PROD_CONTAINER) psql -U $(PROD_DB_USER) -d template1 -tc \"SELECT 1 FROM pg_database WHERE datname = '$(PROD_DB)'\" | grep -q 1 || sudo /usr/local/bin/docker exec $(PROD_CONTAINER) psql -U $(PROD_DB_USER) -d template1 -c 'CREATE DATABASE $(PROD_DB);'"
	@echo "$(GREEN)âœ“ Base de datos verificada/creada$(NC)"

.PHONY: prod-apply-schema
prod-apply-schema: ## Aplicar schema completo en producciÃ³n
	@echo "$(BLUE)ğŸ“ Aplicando schema en producciÃ³n...$(NC)"
	@$(SCP) scripts/complete-production-schema.sql $(PROD_USER)@$(PROD_HOST):/tmp/
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker exec -i $(PROD_CONTAINER) psql -U $(PROD_DB_USER) -d $(PROD_DB) < /tmp/complete-production-schema.sql"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "rm /tmp/complete-production-schema.sql"
	@echo "$(GREEN)âœ“ Schema aplicado$(NC)"

.PHONY: prod-apply-sql
prod-apply-sql: ## Aplicar archivo SQL en producciÃ³n (usar: make prod-apply-sql FILE=path/to/file.sql)
	@if [ -z "$(FILE)" ]; then \
		echo "$(RED)Error: Especifica el archivo con FILE=path/to/file.sql$(NC)"; \
		exit 1; \
	fi
	@echo "$(BLUE)ğŸ“ Aplicando $(FILE) en producciÃ³n...$(NC)"
	@scp $(FILE) $(PROD_USER)@$(PROD_HOST):/tmp/temp_migration.sql
	@ssh $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker exec -i $(PROD_CONTAINER) psql -U $(PROD_DB_USER) -d $(PROD_DB) < /tmp/temp_migration.sql"
	@ssh $(PROD_USER)@$(PROD_HOST) "rm /tmp/temp_migration.sql"
	@echo "$(GREEN)âœ“ SQL aplicado$(NC)"

.PHONY: prod-apply-migration
prod-apply-migration: ## Aplicar migraciÃ³n especÃ­fica (usar: make prod-apply-migration FILE=001-fix-transaction-id.sql)
	@if [ -z "$(FILE)" ]; then \
		echo "$(RED)Error: Especifica el archivo con FILE=nombre-migracion.sql$(NC)"; \
		exit 1; \
	fi
	@echo "$(BLUE)ğŸ”„ Aplicando migraciÃ³n $(FILE) en producciÃ³n...$(NC)"
	@SSHPASS='$(SSHPASS)' SUDO_PASS='$(SUDO_PASS)' $(MAKE) -f Makefile.production prod-apply-sql FILE=migrations/$(FILE)

.PHONY: prod-fix-permissions
prod-fix-permissions: ## Arreglar permisos de archivos en el NAS
	@echo "$(BLUE)ğŸ”§ Arreglando permisos...$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo chmod -R 644 $(PROD_PATH)/config/*.sql"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo chown -R $(PROD_USER):users $(PROD_PATH)/config/"
	@echo "$(GREEN)âœ“ Permisos corregidos$(NC)"

# =============================================================================
# ğŸ”´ COMANDOS DE PRODUCCIÃ“N - Build y Deploy
# =============================================================================

.PHONY: prod-build-image
prod-build-image: ## ğŸ—ï¸ Construir imagen Docker de producciÃ³n
	@echo "$(BLUE)ğŸ—ï¸ Construyendo imagen de producciÃ³n...$(NC)"
	@echo "$(YELLOW)1. Compilando TypeScript...$(NC)"
	@npm run build
	@echo "$(YELLOW)2. Construyendo imagen Docker...$(NC)"
	@docker build -f Dockerfile -t ai-service:simple .
	@echo "$(YELLOW)3. Exportando imagen...$(NC)"
	@docker save ai-service:simple | gzip > ai-service-production.tar.gz
	@echo "$(GREEN)âœ“ Imagen creada: ai-service-production.tar.gz$(NC)"
	@ls -lh ai-service-production.tar.gz

.PHONY: prod-deploy-image
prod-deploy-image: ## Deploy imagen Docker a producciÃ³n con backup automÃ¡tico
	@echo "$(BLUE)ğŸ“¦ Desplegando imagen Docker a producciÃ³n...$(NC)"
	@if [ ! -f ai-service-production.tar.gz ]; then \
		echo "$(RED)Error: No se encuentra ai-service-production.tar.gz$(NC)"; \
		exit 1; \
	fi
	@echo "$(YELLOW)ğŸ“¸ Creando backup pre-deploy...$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "cd $(PROD_PATH) && ./scripts/emergency/pre-deploy-backup.sh remote"
	@echo "$(YELLOW)Copiando imagen al NAS...$(NC)"
	@$(SCP) ai-service-production.tar.gz $(PROD_USER)@$(PROD_HOST):/tmp/
	@echo "$(YELLOW)Cargando imagen en Docker...$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "cd /tmp && sudo sh -c 'gunzip -c ai-service-production.tar.gz | /usr/local/bin/docker load'"
	@echo "$(GREEN)âœ“ Imagen ai-service:simple cargada$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "rm /tmp/ai-service-production.tar.gz"
	@echo "$(YELLOW)Reiniciando servicios...$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "cd $(PROD_PATH) && sudo /usr/local/bin/docker-compose up -d"
	@echo "$(GREEN)âœ“ Deploy completado$(NC)"
	@echo "$(YELLOW)ğŸ’¡ En caso de problemas: make prod-emergency-restore$(NC)"
	@sleep 5
	@$(MAKE) prod-health

.PHONY: prod-force-recreate
prod-force-recreate: ## Forzar recreaciÃ³n de contenedores con Ãºltima imagen
	@echo "$(BLUE)ğŸ”„ Forzando recreaciÃ³n de contenedores...$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "cd $(PROD_PATH) && sudo /usr/local/bin/docker-compose pull"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "cd $(PROD_PATH) && sudo /usr/local/bin/docker-compose up -d --force-recreate"
	@echo "$(GREEN)âœ“ Contenedores recreados con Ãºltima versiÃ³n$(NC)"
	@sleep 5
	@$(MAKE) prod-health

.PHONY: prod-update-config
prod-update-config: ## Actualizar configuraciÃ³n de docker-compose en producciÃ³n con backup
	@echo "$(BLUE)ğŸ”§ Actualizando configuraciÃ³n en producciÃ³n...$(NC)"
	@echo "$(YELLOW)ğŸ“¸ Creando backup de configuraciÃ³n...$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "cp $(PROD_PATH)/docker-compose.yml $(PROD_PATH)/docker-compose.yml.backup-$(shell date +%Y%m%d_%H%M%S) 2>/dev/null || true"
	@$(SCP) docker-compose.production.yml $(PROD_USER)@$(PROD_HOST):$(PROD_PATH)/docker-compose.yml
	@echo "$(GREEN)âœ“ ConfiguraciÃ³n actualizada$(NC)"
	@echo "$(YELLOW)Copiando archivo .env...$(NC)"
	@$(SCP) .env $(PROD_USER)@$(PROD_HOST):/tmp/.env.tmp
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo mv /tmp/.env.tmp $(PROD_PATH)/.env && sudo chown $(PROD_USER):users $(PROD_PATH)/.env"
	@echo "$(GREEN)âœ“ Variables de entorno actualizadas$(NC)"
	@echo "$(YELLOW)Creando directorios necesarios...$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo mkdir -p $(PROD_PATH)/postgres $(PROD_PATH)/redis $(PROD_PATH)/logs $(PROD_PATH)/documents $(PROD_PATH)/config"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo chown -R $(PROD_USER):users $(PROD_PATH)/postgres $(PROD_PATH)/redis $(PROD_PATH)/logs $(PROD_PATH)/documents $(PROD_PATH)/config"
	@echo "$(YELLOW)Reiniciando servicios...$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "cd $(PROD_PATH) && sudo /usr/local/bin/docker-compose down --remove-orphans"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "cd $(PROD_PATH) && sudo /usr/local/bin/docker-compose up -d --force-recreate"
	@echo "$(GREEN)âœ“ Servicios reiniciados$(NC)"
	@echo "$(YELLOW)ğŸ’¡ En caso de problemas: make prod-emergency-restore$(NC)"
	@sleep 5
	@echo "$(BLUE)ğŸ“‹ Revisando logs del servicio...$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker logs ai-service --tail=20"

.PHONY: prod-logs
prod-logs: ## Ver logs del servicio AI
	@echo "$(BLUE)ğŸ“‹ Logs del servicio AI...$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker logs ai-service --tail=50"

.PHONY: prod-up
prod-up: ## Levantar todos los servicios con docker-compose
	@echo "$(BLUE)ğŸš€ Levantando servicios en producciÃ³n...$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "cd $(PROD_PATH) && sudo /usr/local/bin/docker-compose up -d"
	@echo "$(GREEN)âœ“ Servicios iniciados$(NC)"
	@sleep 5
	@$(MAKE) -f Makefile.production prod-status

.PHONY: prod-ps
prod-ps: ## Ver todos los contenedores
	@echo "$(BLUE)ğŸ“‹ Contenedores en producciÃ³n...$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker ps -a | grep -E 'ai-|CONTAINER'"

.PHONY: prod-start
prod-start: ## Iniciar el servicio AI
	@echo "$(BLUE)ğŸš€ Iniciando servicio AI...$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker start ai-service"
	@echo "$(GREEN)âœ“ Servicio iniciado$(NC)"

.PHONY: prod-logs-full
prod-logs-full: ## Ver logs completos del servicio AI
	@echo "$(BLUE)ğŸ“‹ Logs completos del servicio AI...$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker logs ai-service"

.PHONY: prod-logs-postgres
prod-logs-postgres: ## Ver logs de PostgreSQL
	@echo "$(BLUE)ğŸ“‹ Logs de PostgreSQL...$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker logs ai-postgres --tail=30"

.PHONY: prod-reset-postgres
prod-reset-postgres: ## Limpiar y reinicializar PostgreSQL
	@echo "$(RED)âš ï¸  Limpiando datos de PostgreSQL (versiÃ³n incompatible)...$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "cd $(PROD_PATH) && sudo /usr/local/bin/docker-compose stop"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker rm ai-postgres || true"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo rm -rf $(PROD_PATH)/postgres"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo mkdir -p $(PROD_PATH)/postgres"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo chown -R $(PROD_USER):users $(PROD_PATH)/postgres"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo ls -la $(PROD_PATH)/postgres/"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "cd $(PROD_PATH) && sudo /usr/local/bin/docker-compose up -d"
	@echo "$(GREEN)âœ“ PostgreSQL reinicializado$(NC)"

# =============================================================================
# ğŸ”´ COMANDOS DE PRODUCCIÃ“N - DiagnÃ³stico
# =============================================================================

.PHONY: prod-status
prod-status: ## Estado completo del sistema en producciÃ³n
	@echo "$(BLUE)ğŸ“Š ESTADO DE PRODUCCIÃ“N$(NC)"
	@echo "$(YELLOW)â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”$(NC)"
	@echo "$(BLUE)Servicio AI:$(NC)"
	@-curl -s http://$(PROD_HOST):3003/status | python3 -m json.tool | head -20
	@echo ""
	@echo "$(BLUE)Contenedores:$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker ps --format 'table {{.Names}}\t{{.Status}}\t{{.Ports}}' | grep -E '(ai-|postgres|redis|watchtower)' || echo 'No hay contenedores AI corriendo'"
	@echo ""
	@echo "$(BLUE)Base de datos:$(NC)"
	@$(MAKE) -f Makefile.production prod-check-db --no-print-directory

.PHONY: prod-check-containers
prod-check-containers: ## Ver todos los contenedores en el NAS
	@echo "$(BLUE)ğŸ³ Contenedores en producciÃ³n:$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker ps -a --format 'table {{.Names}}\t{{.Status}}\t{{.Image}}' | head -20"

.PHONY: prod-check-db
prod-check-db: ## Verificar BD y tablas en producciÃ³n
	@echo "$(BLUE)ğŸ—„ï¸  Verificando base de datos...$(NC)"
	@echo -n "ConexiÃ³n: "
	@if $(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker exec $(PROD_CONTAINER) pg_isready -U $(PROD_DB_USER) -d $(PROD_DB)" >/dev/null 2>&1; then \
		echo "$(GREEN)âœ“ OK$(NC)"; \
	else \
		echo "$(RED)âœ— ERROR$(NC)"; \
	fi
	@echo -n "Tablas financial: "
	@COUNT=$$($(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker exec $(PROD_CONTAINER) psql -U $(PROD_DB_USER) -d $(PROD_DB) -t -c \"SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'financial';\"" 2>/dev/null | tr -d ' '); \
	echo "$(GREEN)$$COUNT tablas$(NC)"

.PHONY: prod-health
prod-health: ## Health check completo de producciÃ³n
	@echo "$(BLUE)ğŸ¥ Health Check ProducciÃ³n$(NC)"
	@echo "$(YELLOW)â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”$(NC)"
	@STATUS=$$(curl -s http://$(PROD_HOST):3003/status | python3 -c "import sys, json; d=json.load(sys.stdin); print(d.get('status', 'unknown'))" 2>/dev/null || echo "error"); \
	if [ "$$STATUS" = "healthy" ]; then \
		echo "Estado: $(GREEN)âœ“ $$STATUS$(NC)"; \
	elif [ "$$STATUS" = "degraded" ]; then \
		echo "Estado: $(YELLOW)âš  $$STATUS$(NC)"; \
	else \
		echo "Estado: $(RED)âœ— $$STATUS$(NC)"; \
	fi
	@echo -n "Dashboard: "
	@if curl -s http://$(PROD_HOST):3003/api/financial/dashboard/overview | grep -q '"success":true' 2>/dev/null; then \
		echo "$(GREEN)âœ“ Funcionando$(NC)"; \
	else \
		echo "$(RED)âœ— Con errores$(NC)"; \
	fi

# =============================================================================
# ğŸ”´ COMANDOS DE PRODUCCIÃ“N - Backup
# =============================================================================

.PHONY: prod-backup
prod-backup: ## Backup de producciÃ³n con timestamp
	@echo "$(BLUE)ğŸ’¾ Creando backup de producciÃ³n...$(NC)"
	@TIMESTAMP=$$(date +%Y%m%d_%H%M%S); \
	$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo mkdir -p $(BACKUP_DIR)"; \
	$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker exec $(PROD_CONTAINER) pg_dump -U $(PROD_DB_USER) -d $(PROD_DB) | gzip > /tmp/backup_$$TIMESTAMP.sql.gz"; \
	$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo mv /tmp/backup_$$TIMESTAMP.sql.gz $(BACKUP_DIR)/"; \
	echo "$(GREEN)âœ“ Backup creado: backup_$$TIMESTAMP.sql.gz$(NC)"

.PHONY: prod-backup-list
prod-backup-list: ## Listar backups disponibles en el NAS
	@echo "$(BLUE)ğŸ“‹ Backups disponibles:$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "ls -lah $(BACKUP_DIR)/*.sql.gz 2>/dev/null | tail -10" || echo "$(YELLOW)No hay backups$(NC)"

.PHONY: prod-restore
prod-restore: ## Restaurar backup especÃ­fico (usar: make prod-restore FILE=backup_20250101_120000.sql.gz)
	@if [ -z "$(FILE)" ]; then \
		echo "$(RED)Error: Especifica el archivo con FILE=backup_XXXXXX.sql.gz$(NC)"; \
		echo "Usa 'make prod-backup-list' para ver backups disponibles"; \
		exit 1; \
	fi
	@echo "$(YELLOW)âš ï¸  Restaurando backup: $(FILE)$(NC)"
	@echo "$(RED)Esto reemplazarÃ¡ TODOS los datos actuales. Â¿Continuar? (s/N):$(NC)"
	@read CONFIRM && [ "$$CONFIRM" = "s" ] || (echo "$(GREEN)Cancelado$(NC)" && exit 1)
	@echo "$(BLUE)Restaurando...$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "gunzip -c $(BACKUP_DIR)/$(FILE) | sudo /usr/local/bin/docker exec -i $(PROD_CONTAINER) psql -U $(PROD_DB_USER) -d $(PROD_DB)"
	@echo "$(GREEN)âœ“ Backup restaurado$(NC)"

# =============================================================================
# ğŸ”„ RESTAURACIÃ“N COMPLETA DE PRODUCCIÃ“N
# =============================================================================

.PHONY: prod-restore-from-dev
prod-restore-from-dev: ## PELIGRO: Restaurar producciÃ³n con schema de desarrollo
	@echo "$(RED)âš ï¸  ADVERTENCIA CRÃTICA âš ï¸$(NC)"
	@echo "$(RED)â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•$(NC)"
	@echo "$(RED)Esto ELIMINARÃ la base de datos de producciÃ³n actual$(NC)"
	@echo "$(RED)y la REEMPLAZARÃ con el schema de desarrollo$(NC)"
	@echo "$(RED)â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•$(NC)"
	@echo ""
	@echo "$(YELLOW)Se realizarÃ¡n las siguientes acciones:$(NC)"
	@echo "  1. Backup completo de producciÃ³n actual"
	@echo "  2. Export del schema de desarrollo"
	@echo "  3. Detener servicios de producciÃ³n"
	@echo "  4. Eliminar y recrear base de datos"
	@echo "  5. Aplicar schema de desarrollo"
	@echo "  6. Migrar datos existentes (si es posible)"
	@echo "  7. Reiniciar servicios"
	@echo ""
	@echo "$(RED)Â¿EstÃ¡s ABSOLUTAMENTE SEGURO? (escribir 'RESTAURAR PRODUCCION'):$(NC)"
	@read CONFIRM && [ "$$CONFIRM" = "RESTAURAR PRODUCCION" ] || (echo "$(GREEN)OperaciÃ³n cancelada$(NC)" && exit 1)
	@echo ""
	@echo "$(BLUE)Paso 1/7: Creando backup completo...$(NC)"
	@$(MAKE) -f Makefile.production prod-backup
	@echo "$(GREEN)âœ“ Backup creado$(NC)"
	@echo ""
	@echo "$(BLUE)Paso 2/7: Exportando schema de desarrollo...$(NC)"
	@docker exec ai-service-postgres-1 pg_dump -U postgres -d ai_service --schema-only --no-owner --no-privileges > /tmp/dev-schema-restore.sql 2>/dev/null || \
		(echo "$(YELLOW)Desarrollo no activo, usando schema de respaldo...$(NC)" && \
		cp migrations/baseline-schema.sql /tmp/dev-schema-restore.sql)
	@echo "$(GREEN)âœ“ Schema exportado$(NC)"
	@echo ""
	@echo "$(BLUE)Paso 3/7: Deteniendo servicios...$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker stop ai-service"
	@echo "$(GREEN)âœ“ Servicios detenidos$(NC)"
	@echo ""
	@echo "$(BLUE)Paso 4/7: Recreando base de datos...$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker exec $(PROD_CONTAINER) psql -U $(PROD_DB_USER) -d postgres -c 'DROP DATABASE IF EXISTS $(PROD_DB);'"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker exec $(PROD_CONTAINER) psql -U $(PROD_DB_USER) -d postgres -c 'CREATE DATABASE $(PROD_DB) OWNER $(PROD_DB_USER);'"
	@echo "$(GREEN)âœ“ Base de datos recreada$(NC)"
	@echo ""
	@echo "$(BLUE)Paso 5/7: Aplicando schema de desarrollo...$(NC)"
	@$(SCP) /tmp/dev-schema-restore.sql $(PROD_USER)@$(PROD_HOST):/tmp/
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "cat /tmp/dev-schema-restore.sql | sudo /usr/local/bin/docker exec -i $(PROD_CONTAINER) psql -U $(PROD_DB_USER) -d $(PROD_DB)"
	@echo "$(GREEN)âœ“ Schema aplicado$(NC)"
	@echo ""
	@echo "$(BLUE)Paso 6/7: Aplicando migraciones pendientes...$(NC)"
	@echo "$(YELLOW)Migraciones incluidas en schema base$(NC)"
	@echo "$(GREEN)âœ“ Schema completo aplicado$(NC)"
	@echo ""
	@echo "$(BLUE)Paso 7/7: Reiniciando servicios...$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker start ai-service"
	@sleep 10
	@echo "$(GREEN)âœ“ Servicios reiniciados$(NC)"
	@echo ""
	@echo "$(GREEN)â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•$(NC)"
	@echo "$(GREEN)âœ… RESTAURACIÃ“N COMPLETA$(NC)"
	@echo "$(GREEN)â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•$(NC)"
	@echo ""
	@echo "$(YELLOW)Verificando estado...$(NC)"
	@$(MAKE) -f Makefile.production prod-status

# =============================================================================
# ğŸ”„ PRISMA MIGRATIONS (Database Schema Management)
# =============================================================================

.PHONY: prod-migrate-status
prod-migrate-status: ## Check Prisma migration status in production
	@echo "$(BLUE)ğŸ” Checking migration status in production...$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker exec ai-service sh -c 'DATABASE_URL=postgresql://$(PROD_DB_USER):\$$POSTGRES_PASSWORD@ai-postgres:5432/$(PROD_DB) npx prisma migrate status' 2>&1" || \
	echo "$(YELLOW)âš ï¸  If migrations are missing, run: make prod-migrate-deploy$(NC)"

.PHONY: prod-migrate-deploy
prod-migrate-deploy: ## Apply pending Prisma migrations to production (SAFE)
	@echo "$(BLUE)ğŸš€ Applying Prisma migrations to production...$(NC)"
	@echo "$(YELLOW)This will apply all pending migrations from prisma/migrations$(NC)"
	@echo "$(YELLOW)Continue? (y/N):$(NC)"
	@read CONFIRM && [ "$$CONFIRM" = "y" ] || (echo "$(GREEN)Cancelled$(NC)" && exit 1)
	@echo "$(BLUE)Creating backup first...$(NC)"
	@$(MAKE) -f Makefile.production prod-backup
	@echo "$(BLUE)Applying migrations...$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker exec ai-service sh -c 'DATABASE_URL=postgresql://$(PROD_DB_USER):\$$POSTGRES_PASSWORD@ai-postgres:5432/$(PROD_DB) npx prisma migrate deploy' 2>&1" && \
	echo "$(GREEN)âœ… Migrations applied successfully!$(NC)" || \
	(echo "$(RED)âŒ Migration failed! Check logs above$(NC)" && exit 1)
	@echo "$(BLUE)Verifying schema...$(NC)"
	@$(MAKE) -f Makefile.production prod-check-db

.PHONY: prod-migrate-reset
prod-migrate-reset: ## DANGER: Reset database and apply all migrations from scratch
	@echo "$(RED)âš ï¸  WARNING: This will DELETE ALL DATA and recreate the schema!$(NC)"
	@echo "$(RED)Host: $(PROD_HOST)$(NC)"
	@echo "$(RED)Database: $(PROD_DB)$(NC)"
	@echo "$(YELLOW)Type 'RESET DATABASE' to continue:$(NC)"
	@read CONFIRM && [ "$$CONFIRM" = "RESET DATABASE" ] || (echo "$(GREEN)Cancelled$(NC)" && exit 1)
	@echo "$(BLUE)Creating final backup...$(NC)"
	@$(MAKE) -f Makefile.production prod-backup
	@echo "$(RED)Resetting database...$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker exec ai-service sh -c 'DATABASE_URL=postgresql://$(PROD_DB_USER):\$$POSTGRES_PASSWORD@ai-postgres:5432/$(PROD_DB) npx prisma migrate reset --force' 2>&1" && \
	echo "$(GREEN)âœ… Database reset and migrations applied!$(NC)" || \
	(echo "$(RED)âŒ Reset failed!$(NC)" && exit 1)

.PHONY: prod-migrate-create
prod-migrate-create: ## Create a new migration from local development
	@echo "$(BLUE)ğŸ“ Creating new migration from current schema...$(NC)"
	@read -p "Enter migration name (e.g., add_new_field): " NAME; \
	if [ -z "$$NAME" ]; then \
		echo "$(RED)âŒ Migration name is required$(NC)"; \
		exit 1; \
	fi; \
	npx prisma migrate dev --name $$NAME --create-only && \
	echo "$(GREEN)âœ… Migration created: prisma/migrations/*_$$NAME$(NC)" && \
	echo "$(YELLOW)Review the migration, then run 'make prod-migrate-deploy' to apply$(NC)"

.PHONY: prod-prisma-generate
prod-prisma-generate: ## Generate Prisma client in production container
	@echo "$(BLUE)ğŸ”§ Generating Prisma client in production...$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker exec ai-service npx prisma generate" && \
	echo "$(GREEN)âœ… Prisma client generated$(NC)" || \
	echo "$(RED)âŒ Failed to generate Prisma client$(NC)"

# =============================================================================
# ğŸ” TEST DE AUTENTICACIÃ“N
# =============================================================================

.PHONY: test-auth
test-auth: ## Test authentication (SSH and sudo)
	@echo "$(BLUE)ğŸ” Testing authentication...$(NC)"
	@echo "1. Checking variables are defined:"
	@echo "   SSHPASS: $$([ -n '$(SSHPASS)' ] && echo 'âœ“ Defined' || echo 'âœ— Not defined')"
	@echo "   SUDO_PASS: $$([ -n '$(SUDO_PASS)' ] && echo 'âœ“ Defined' || echo 'âœ— Not defined')"
	@echo ""
	@echo "2. Testing SSH connection:"
	@SSHPASS='$(SSHPASS)' sshpass -e ssh -o StrictHostKeyChecking=no $(PROD_USER)@$(PROD_HOST) "echo '   âœ“ SSH connection successful'" || echo "   âœ— SSH failed"
	@echo ""
	@echo "3. Testing sudo with password:"
	@SSHPASS='$(SSHPASS)' sshpass -e ssh -o StrictHostKeyChecking=no $(PROD_USER)@$(PROD_HOST) "sudo echo '   âœ“ Sudo authentication successful'" || echo "   âœ— Sudo failed"

# =============================================================================
# ğŸ”‘ COMANDOS DE PRODUCCIÃ“N - Authentication Management
# =============================================================================

.PHONY: prod-auth-create-admin
prod-auth-create-admin: ## Crear usuario admin (admin@ai-service.local / admin123)
	@echo "$(BLUE)ğŸ‘¤ Creating admin user in production...$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker exec $(PROD_CONTAINER) psql -U $(PROD_DB_USER) -d $(PROD_DB) -c \"INSERT INTO users (email, password_hash, full_name, role) VALUES ('admin@ai-service.local', '\\\$$2b\\\$$10\\\$$8YzH7X1vKpFdKjb8rqOAOe8uEpZ4UjQn9mGxK7bgQqFvI9o1aWVKq', 'System Administrator', 'admin') ON CONFLICT (email) DO UPDATE SET password_hash = EXCLUDED.password_hash;\" 2>/dev/null" && \
	echo "$(GREEN)âœ… Admin user created/updated$(NC)" && \
	echo "ğŸ“§ Email: admin@ai-service.local" && \
	echo "ğŸ”‘ Password: admin123" || \
	echo "$(RED)âŒ Failed to create admin user$(NC)"

.PHONY: prod-auth-list-users
prod-auth-list-users: ## Listar todos los usuarios en producciÃ³n
	@echo "$(BLUE)ğŸ“‹ Listing production users...$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker exec $(PROD_CONTAINER) psql -U $(PROD_DB_USER) -d $(PROD_DB) -c \"SELECT email, full_name, role, is_active, created_at FROM users ORDER BY created_at DESC;\" 2>/dev/null" || \
	echo "$(RED)âŒ Could not list users. Check if auth tables exist.$(NC)"

.PHONY: prod-auth-reset-attempts
prod-auth-reset-attempts: ## Limpiar todos los intentos de login en producciÃ³n
	@echo "$(YELLOW)ğŸ”“ Resetting login attempts in production...$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker exec $(PROD_CONTAINER) psql -U $(PROD_DB_USER) -d $(PROD_DB) -c \"DELETE FROM login_attempts;\" 2>/dev/null" && \
	echo "$(GREEN)âœ… Login attempts cleared$(NC)" || \
	echo "$(RED)âŒ Could not reset attempts. Check if auth tables exist.$(NC)"

.PHONY: prod-auth-check-attempts
prod-auth-check-attempts: ## Ver intentos recientes de login en producciÃ³n
	@echo "$(BLUE)ğŸ” Checking recent login attempts in production...$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker exec $(PROD_CONTAINER) psql -U $(PROD_DB_USER) -d $(PROD_DB) -c \"SELECT email, ip_address, success, attempted_at FROM login_attempts ORDER BY attempted_at DESC LIMIT 20;\" 2>/dev/null" || \
	echo "$(RED)âŒ Could not check attempts. Check if auth tables exist.$(NC)"

.PHONY: prod-auth-reset-password
prod-auth-reset-password: ## Resetear contraseÃ±a de usuario en producciÃ³n (interactivo)
	@echo "$(BLUE)ğŸ”‘ Reset user password in production$(NC)"
	@read -p "Enter email: " email; \
	read -s -p "Enter new password: " password; \
	echo; \
	if [ -z "$$email" ] || [ -z "$$password" ]; then \
		echo "$(RED)âŒ Email and password are required$(NC)"; \
		exit 1; \
	fi; \
	HASH=$$(docker run --rm node:20-alpine sh -c "npm install bcrypt && node -e \"const bcrypt = require('bcrypt'); bcrypt.hash('$$password', 10).then(h => console.log(h))\"" 2>/dev/null | tail -1); \
	if [ -z "$$HASH" ]; then \
		echo "$(RED)âŒ Failed to generate password hash$(NC)"; \
		exit 1; \
	fi; \
	$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker exec $(PROD_CONTAINER) psql -U $(PROD_DB_USER) -d $(PROD_DB) -c \"UPDATE users SET password_hash = '$$HASH' WHERE email = '$$email' RETURNING email;\" 2>/dev/null" | grep -q "1 row" && \
	echo "$(GREEN)âœ… Password updated for $$email$(NC)" || \
	echo "$(RED)âŒ User not found or update failed$(NC)"

.PHONY: prod-auth-check-tables
prod-auth-check-tables: ## Verificar si existen las tablas de autenticaciÃ³n
	@echo "$(BLUE)ğŸ” Checking auth tables in production...$(NC)"
	@TABLES=$$($(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker exec $(PROD_CONTAINER) psql -U $(PROD_DB_USER) -d $(PROD_DB) -t -c \"SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name IN ('users', 'refresh_tokens', 'login_attempts');\" 2>/dev/null" | tr -d ' \n'); \
	if [ -z "$$TABLES" ]; then \
		echo "$(RED)âŒ Auth tables not found$(NC)"; \
		echo "$(YELLOW)Run 'make prod-sql-file FILE=migrations/006-minimal-auth-tables.sql' to create them$(NC)"; \
	else \
		echo "$(GREEN)âœ… Auth tables found: $$TABLES$(NC)"; \
	fi

# =============================================================================
# Ayuda
# =============================================================================

.PHONY: help
help: ## Mostrar esta ayuda
	@echo "$(RED)â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—$(NC)"
	@echo "$(RED)â•‘          COMANDOS DE PRODUCCIÃ“N - USAR CON CUIDADO           â•‘$(NC)"
	@echo "$(RED)â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•$(NC)"
	@echo ""
	@grep -E '^[a-zA-Z_-]+:.*?## .*$$' $(MAKEFILE_LIST) | awk 'BEGIN {FS = ":.*?## "}; {printf "$(YELLOW)%-20s$(NC) %s\n", $$1, $$2}'
	@echo ""
	@echo "$(RED)âš ï¸  ADVERTENCIA: Estos comandos afectan el ambiente de PRODUCCIÃ“N$(NC)"

.DEFAULT_GOAL := help