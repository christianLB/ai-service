# Makefile.production - Comandos espec√≠ficos para producci√≥n
# ADVERTENCIA: Estos comandos afectan PRODUCCI√ìN. Usar con cuidado.

include .make.env

# Export variables for SSH authentication
export SSHPASS
export SUDO_PASS

# Variables de producci√≥n
PROD_HOST := 192.168.1.11
PROD_USER := k2600x
PROD_PATH := /volume1/docker/ai-service
PROD_DB := ai_service
PROD_DB_USER := ai_user
PROD_CONTAINER := ai-postgres
BACKUP_DIR := $(PROD_PATH)/backups

# SSH con clave SSH (sin contrase√±a)
SSH := ssh
SCP := scp

# Colores
RED := \033[0;31m
GREEN := \033[0;32m
YELLOW := \033[0;33m
BLUE := \033[0;34m
NC := \033[0m

# =============================================================================
# üîß COMANDOS DE SQL DIRECTO
# =============================================================================

.PHONY: prod-sql
prod-sql: ## Ejecutar SQL directo en producci√≥n (usar: make prod-sql SQL="SELECT 1")
	@if [ -z "$(SQL)" ]; then \
		echo "$(RED)Error: Especifica SQL=\"tu consulta SQL\"$(NC)"; \
		exit 1; \
	fi
	@echo "$(BLUE)Ejecutando SQL en producci√≥n...$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker exec ai-postgres psql -U $(PROD_DB_USER) -d $(PROD_DB) -c \"$(SQL)\""

.PHONY: prod-sql-file
prod-sql-file: ## Ejecutar archivo SQL en producci√≥n (usar: make prod-sql-file FILE=script.sql)
	@if [ -z "$(FILE)" ]; then \
		echo "$(RED)Error: Especifica FILE=ruta/al/archivo.sql$(NC)"; \
		exit 1; \
	fi
	@echo "$(BLUE)Ejecutando archivo SQL: $(FILE)$(NC)"
	@cat $(FILE) | $(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker exec -i ai-postgres psql -U $(PROD_DB_USER) -d $(PROD_DB)"

# =============================================================================
# üî¥ COMANDOS DE PRODUCCI√ìN - Reset y Recovery
# =============================================================================

.PHONY: prod-reset-db
prod-reset-db: ## Reset completo de BD en PRODUCCI√ìN (con confirmaci√≥n)
	@echo "$(RED)‚ö†Ô∏è  ADVERTENCIA: Esto ELIMINAR√Å TODOS LOS DATOS en PRODUCCI√ìN$(NC)"
	@echo "$(RED)Host: $(PROD_HOST)$(NC)"
	@echo "$(RED)Base de datos: $(PROD_DB)$(NC)"
	@echo "$(YELLOW)¬øEst√°s ABSOLUTAMENTE SEGURO? Escribe 'SI ELIMINAR TODO' para continuar:$(NC)"
	@read CONFIRM && [ "$$CONFIRM" = "SI ELIMINAR TODO" ] || (echo "$(GREEN)Cancelado$(NC)" && exit 1)
	@$(MAKE) prod-backup
	@echo "$(YELLOW)Ejecutando reset...$(NC)"
	@$(MAKE) prod-reset-db-force

.PHONY: prod-reset-db-force
prod-reset-db-force: ## Reset sin confirmaci√≥n (solo para emergencias)
	@echo "$(RED)üî• RESET FORZADO EN PRODUCCI√ìN$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker stop ai-service ai-postgres ai-redis || true"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo rm -rf $(PROD_PATH)/postgres-data/*"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker start ai-postgres"
	@sleep 10
	@$(MAKE) prod-create-db
	@$(MAKE) prod-apply-schema
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker start ai-redis ai-service"
	@sleep 10
	@$(MAKE) prod-health

.PHONY: prod-create-db
prod-create-db: ## Crear base de datos en producci√≥n si no existe
	@echo "$(BLUE)üìä Creando base de datos si no existe...$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker exec $(PROD_CONTAINER) psql -U $(PROD_DB_USER) -d template1 -tc \"SELECT 1 FROM pg_database WHERE datname = '$(PROD_DB)'\" | grep -q 1 || sudo /usr/local/bin/docker exec $(PROD_CONTAINER) psql -U $(PROD_DB_USER) -d template1 -c 'CREATE DATABASE $(PROD_DB);'"
	@echo "$(GREEN)‚úì Base de datos verificada/creada$(NC)"

.PHONY: prod-apply-schema
prod-apply-schema: ## Aplicar schema completo en producci√≥n
	@echo "$(BLUE)üìù Aplicando schema en producci√≥n...$(NC)"
	@$(SCP) scripts/complete-production-schema.sql $(PROD_USER)@$(PROD_HOST):/tmp/
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker exec -i $(PROD_CONTAINER) psql -U $(PROD_DB_USER) -d $(PROD_DB) < /tmp/complete-production-schema.sql"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "rm /tmp/complete-production-schema.sql"
	@echo "$(GREEN)‚úì Schema aplicado$(NC)"

.PHONY: prod-apply-sql
prod-apply-sql: ## Aplicar archivo SQL en producci√≥n (usar: make prod-apply-sql FILE=path/to/file.sql)
	@if [ -z "$(FILE)" ]; then \
		echo "$(RED)Error: Especifica el archivo con FILE=path/to/file.sql$(NC)"; \
		exit 1; \
	fi
	@echo "$(BLUE)üìù Aplicando $(FILE) en producci√≥n...$(NC)"
	@scp $(FILE) $(PROD_USER)@$(PROD_HOST):/tmp/temp_migration.sql
	@ssh $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker exec -i $(PROD_CONTAINER) psql -U $(PROD_DB_USER) -d $(PROD_DB) < /tmp/temp_migration.sql"
	@ssh $(PROD_USER)@$(PROD_HOST) "rm /tmp/temp_migration.sql"
	@echo "$(GREEN)‚úì SQL aplicado$(NC)"

.PHONY: prod-apply-migration
prod-apply-migration: ## Aplicar migraci√≥n espec√≠fica (usar: make prod-apply-migration FILE=001-fix-transaction-id.sql)
	@if [ -z "$(FILE)" ]; then \
		echo "$(RED)Error: Especifica el archivo con FILE=nombre-migracion.sql$(NC)"; \
		exit 1; \
	fi
	@echo "$(BLUE)üîÑ Aplicando migraci√≥n $(FILE) en producci√≥n...$(NC)"
	@SSHPASS='$(SSHPASS)' SUDO_PASS='$(SUDO_PASS)' $(MAKE) -f Makefile.production prod-apply-sql FILE=migrations/$(FILE)

.PHONY: prod-fix-permissions
prod-fix-permissions: ## Arreglar permisos de archivos en el NAS
	@echo "$(BLUE)üîß Arreglando permisos...$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo chmod -R 644 $(PROD_PATH)/config/*.sql"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo chown -R $(PROD_USER):users $(PROD_PATH)/config/"
	@echo "$(GREEN)‚úì Permisos corregidos$(NC)"

# =============================================================================
# üî¥ COMANDOS DE PRODUCCI√ìN - Build y Deploy
# =============================================================================

.PHONY: prod-build-image
prod-build-image: ## üèóÔ∏è Construir imagen Docker de producci√≥n
	@echo "$(BLUE)üèóÔ∏è Construyendo imagen de producci√≥n...$(NC)"
	@echo "$(YELLOW)1. Compilando TypeScript...$(NC)"
	@npm run build
	@echo "$(YELLOW)2. Construyendo imagen Docker...$(NC)"
	@docker build -f Dockerfile -t ai-service:simple .
	@echo "$(YELLOW)3. Exportando imagen...$(NC)"
	@docker save ai-service:simple | gzip > ai-service-production.tar.gz
	@echo "$(GREEN)‚úì Imagen creada: ai-service-production.tar.gz$(NC)"
	@ls -lh ai-service-production.tar.gz

.PHONY: prod-deploy-image
prod-deploy-image: ## Deploy imagen Docker a producci√≥n con backup autom√°tico
	@echo "$(BLUE)üì¶ Desplegando imagen Docker a producci√≥n...$(NC)"
	@if [ ! -f ai-service-production.tar.gz ]; then \
		echo "$(RED)Error: No se encuentra ai-service-production.tar.gz$(NC)"; \
		exit 1; \
	fi
	@echo "$(YELLOW)üì∏ Creando backup pre-deploy...$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "cd $(PROD_PATH) && ./scripts/emergency/pre-deploy-backup.sh remote"
	@echo "$(YELLOW)Copiando imagen al NAS...$(NC)"
	@$(SCP) ai-service-production.tar.gz $(PROD_USER)@$(PROD_HOST):/tmp/
	@echo "$(YELLOW)Cargando imagen en Docker...$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "cd /tmp && sudo sh -c 'gunzip -c ai-service-production.tar.gz | /usr/local/bin/docker load'"
	@echo "$(GREEN)‚úì Imagen ai-service:simple cargada$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "rm /tmp/ai-service-production.tar.gz"
	@echo "$(YELLOW)Reiniciando servicios...$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "cd $(PROD_PATH) && sudo /usr/local/bin/docker-compose up -d"
	@echo "$(GREEN)‚úì Deploy completado$(NC)"
	@echo "$(YELLOW)üí° En caso de problemas: make prod-emergency-restore$(NC)"
	@sleep 5
	@$(MAKE) prod-health

.PHONY: prod-force-recreate
prod-force-recreate: ## Forzar recreaci√≥n de contenedores con √∫ltima imagen
	@echo "$(BLUE)üîÑ Forzando recreaci√≥n de contenedores...$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "cd $(PROD_PATH) && sudo /usr/local/bin/docker-compose pull"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "cd $(PROD_PATH) && sudo /usr/local/bin/docker-compose up -d --force-recreate"
	@echo "$(GREEN)‚úì Contenedores recreados con √∫ltima versi√≥n$(NC)"
	@sleep 5
	@$(MAKE) prod-health

.PHONY: prod-update-config
prod-update-config: ## Actualizar configuraci√≥n de docker-compose en producci√≥n con backup
	@echo "$(BLUE)üîß Actualizando configuraci√≥n en producci√≥n...$(NC)"
	@echo "$(YELLOW)üì∏ Creando backup de configuraci√≥n...$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "cp $(PROD_PATH)/docker-compose.yml $(PROD_PATH)/docker-compose.yml.backup-$(shell date +%Y%m%d_%H%M%S) 2>/dev/null || true"
	@$(SCP) docker-compose.production.yml $(PROD_USER)@$(PROD_HOST):$(PROD_PATH)/docker-compose.yml
	@echo "$(GREEN)‚úì Configuraci√≥n actualizada$(NC)"
	@echo "$(YELLOW)Copiando archivo .env...$(NC)"
	@$(SCP) .env $(PROD_USER)@$(PROD_HOST):/tmp/.env.tmp
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo mv /tmp/.env.tmp $(PROD_PATH)/.env && sudo chown $(PROD_USER):users $(PROD_PATH)/.env"
	@echo "$(GREEN)‚úì Variables de entorno actualizadas$(NC)"
	@echo "$(YELLOW)Creando directorios necesarios...$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo mkdir -p $(PROD_PATH)/postgres $(PROD_PATH)/redis $(PROD_PATH)/logs $(PROD_PATH)/documents $(PROD_PATH)/config"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo chown -R $(PROD_USER):users $(PROD_PATH)/postgres $(PROD_PATH)/redis $(PROD_PATH)/logs $(PROD_PATH)/documents $(PROD_PATH)/config"
	@echo "$(YELLOW)Reiniciando servicios...$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "cd $(PROD_PATH) && sudo /usr/local/bin/docker-compose down --remove-orphans"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "cd $(PROD_PATH) && sudo /usr/local/bin/docker-compose up -d --force-recreate"
	@echo "$(GREEN)‚úì Servicios reiniciados$(NC)"
	@echo "$(YELLOW)üí° En caso de problemas: make prod-emergency-restore$(NC)"
	@sleep 5
	@echo "$(BLUE)üìã Revisando logs del servicio...$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker logs ai-service --tail=20"

.PHONY: prod-logs
prod-logs: ## Ver logs del servicio AI
	@echo "$(BLUE)üìã Logs del servicio AI...$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker logs ai-service --tail=50"

.PHONY: prod-up
prod-up: ## Levantar todos los servicios con docker-compose
	@echo "$(BLUE)üöÄ Levantando servicios en producci√≥n...$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "cd $(PROD_PATH) && sudo /usr/local/bin/docker-compose up -d"
	@echo "$(GREEN)‚úì Servicios iniciados$(NC)"
	@sleep 5
	@$(MAKE) -f Makefile.production prod-status

.PHONY: prod-ps
prod-ps: ## Ver todos los contenedores
	@echo "$(BLUE)üìã Contenedores en producci√≥n...$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker ps -a | grep -E 'ai-|CONTAINER'"

.PHONY: prod-start
prod-start: ## Iniciar el servicio AI
	@echo "$(BLUE)üöÄ Iniciando servicio AI...$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker start ai-service"
	@echo "$(GREEN)‚úì Servicio iniciado$(NC)"

.PHONY: prod-logs-full
prod-logs-full: ## Ver logs completos del servicio AI
	@echo "$(BLUE)üìã Logs completos del servicio AI...$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker logs ai-service"

.PHONY: prod-logs-postgres
prod-logs-postgres: ## Ver logs de PostgreSQL
	@echo "$(BLUE)üìã Logs de PostgreSQL...$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker logs ai-postgres --tail=30"

.PHONY: prod-reset-postgres
prod-reset-postgres: ## Limpiar y reinicializar PostgreSQL
	@echo "$(RED)‚ö†Ô∏è  Limpiando datos de PostgreSQL (versi√≥n incompatible)...$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "cd $(PROD_PATH) && sudo /usr/local/bin/docker-compose stop"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker rm ai-postgres || true"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo rm -rf $(PROD_PATH)/postgres"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo mkdir -p $(PROD_PATH)/postgres"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo chown -R $(PROD_USER):users $(PROD_PATH)/postgres"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo ls -la $(PROD_PATH)/postgres/"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "cd $(PROD_PATH) && sudo /usr/local/bin/docker-compose up -d"
	@echo "$(GREEN)‚úì PostgreSQL reinicializado$(NC)"

# =============================================================================
# üî¥ COMANDOS DE PRODUCCI√ìN - Diagn√≥stico
# =============================================================================

.PHONY: prod-status
prod-status: ## Estado completo del sistema en producci√≥n
	@echo "$(BLUE)üìä ESTADO DE PRODUCCI√ìN$(NC)"
	@echo "$(YELLOW)‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ$(NC)"
	@echo "$(BLUE)Servicio AI:$(NC)"
	@-curl -s http://$(PROD_HOST):3003/status | python3 -m json.tool | head -20
	@echo ""
	@echo "$(BLUE)Contenedores:$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker ps --format 'table {{.Names}}\t{{.Status}}\t{{.Ports}}' | grep -E '(ai-|postgres|redis|watchtower)' || echo 'No hay contenedores AI corriendo'"
	@echo ""
	@echo "$(BLUE)Base de datos:$(NC)"
	@$(MAKE) -f Makefile.production prod-check-db --no-print-directory

.PHONY: prod-check-containers
prod-check-containers: ## Ver todos los contenedores en el NAS
	@echo "$(BLUE)üê≥ Contenedores en producci√≥n:$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker ps -a --format 'table {{.Names}}\t{{.Status}}\t{{.Image}}' | head -20"

.PHONY: prod-check-db
prod-check-db: ## Verificar BD y tablas en producci√≥n
	@echo "$(BLUE)üóÑÔ∏è  Verificando base de datos...$(NC)"
	@echo -n "Conexi√≥n: "
	@if $(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker exec $(PROD_CONTAINER) pg_isready -U $(PROD_DB_USER) -d $(PROD_DB)" >/dev/null 2>&1; then \
		echo "$(GREEN)‚úì OK$(NC)"; \
	else \
		echo "$(RED)‚úó ERROR$(NC)"; \
	fi
	@echo -n "Tablas financial: "
	@COUNT=$$($(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker exec $(PROD_CONTAINER) psql -U $(PROD_DB_USER) -d $(PROD_DB) -t -c \"SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'financial';\"" 2>/dev/null | tr -d ' '); \
	echo "$(GREEN)$$COUNT tablas$(NC)"

.PHONY: prod-health
prod-health: ## Health check completo de producci√≥n
	@echo "$(BLUE)üè• Health Check Producci√≥n$(NC)"
	@echo "$(YELLOW)‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ$(NC)"
	@STATUS=$$(curl -s http://$(PROD_HOST):3003/status | python3 -c "import sys, json; d=json.load(sys.stdin); print(d.get('status', 'unknown'))" 2>/dev/null || echo "error"); \
	if [ "$$STATUS" = "healthy" ]; then \
		echo "Estado: $(GREEN)‚úì $$STATUS$(NC)"; \
	elif [ "$$STATUS" = "degraded" ]; then \
		echo "Estado: $(YELLOW)‚ö† $$STATUS$(NC)"; \
	else \
		echo "Estado: $(RED)‚úó $$STATUS$(NC)"; \
	fi
	@echo -n "Dashboard: "
	@if curl -s http://$(PROD_HOST):3003/api/financial/dashboard/overview | grep -q '"success":true' 2>/dev/null; then \
		echo "$(GREEN)‚úì Funcionando$(NC)"; \
	else \
		echo "$(RED)‚úó Con errores$(NC)"; \
	fi

# =============================================================================
# üî¥ COMANDOS DE PRODUCCI√ìN - Backup
# =============================================================================

.PHONY: prod-backup
prod-backup: ## Backup de producci√≥n con timestamp
	@echo "$(BLUE)üíæ Creando backup de producci√≥n...$(NC)"
	@TIMESTAMP=$$(date +%Y%m%d_%H%M%S); \
	$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo mkdir -p $(BACKUP_DIR)"; \
	$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker exec $(PROD_CONTAINER) pg_dump -U $(PROD_DB_USER) -d $(PROD_DB) | gzip > /tmp/backup_$$TIMESTAMP.sql.gz"; \
	$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo mv /tmp/backup_$$TIMESTAMP.sql.gz $(BACKUP_DIR)/"; \
	echo "$(GREEN)‚úì Backup creado: backup_$$TIMESTAMP.sql.gz$(NC)"

.PHONY: prod-backup-list
prod-backup-list: ## Listar backups disponibles en el NAS
	@echo "$(BLUE)üìã Backups disponibles:$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "ls -lah $(BACKUP_DIR)/*.sql.gz 2>/dev/null | tail -10" || echo "$(YELLOW)No hay backups$(NC)"

.PHONY: prod-restore
prod-restore: ## Restaurar backup espec√≠fico (usar: make prod-restore FILE=backup_20250101_120000.sql.gz)
	@if [ -z "$(FILE)" ]; then \
		echo "$(RED)Error: Especifica el archivo con FILE=backup_XXXXXX.sql.gz$(NC)"; \
		echo "Usa 'make prod-backup-list' para ver backups disponibles"; \
		exit 1; \
	fi
	@echo "$(YELLOW)‚ö†Ô∏è  Restaurando backup: $(FILE)$(NC)"
	@echo "$(RED)Esto reemplazar√° TODOS los datos actuales. ¬øContinuar? (s/N):$(NC)"
	@read CONFIRM && [ "$$CONFIRM" = "s" ] || (echo "$(GREEN)Cancelado$(NC)" && exit 1)
	@echo "$(BLUE)Restaurando...$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "gunzip -c $(BACKUP_DIR)/$(FILE) | sudo /usr/local/bin/docker exec -i $(PROD_CONTAINER) psql -U $(PROD_DB_USER) -d $(PROD_DB)"
	@echo "$(GREEN)‚úì Backup restaurado$(NC)"

# =============================================================================
# üîÑ RESTAURACI√ìN COMPLETA DE PRODUCCI√ìN
# =============================================================================

.PHONY: prod-restore-from-dev
prod-restore-from-dev: ## PELIGRO: Restaurar producci√≥n con schema de desarrollo
	@echo "$(RED)‚ö†Ô∏è  ADVERTENCIA CR√çTICA ‚ö†Ô∏è$(NC)"
	@echo "$(RED)‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê$(NC)"
	@echo "$(RED)Esto ELIMINAR√Å la base de datos de producci√≥n actual$(NC)"
	@echo "$(RED)y la REEMPLAZAR√Å con el schema de desarrollo$(NC)"
	@echo "$(RED)‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê$(NC)"
	@echo ""
	@echo "$(YELLOW)Se realizar√°n las siguientes acciones:$(NC)"
	@echo "  1. Backup completo de producci√≥n actual"
	@echo "  2. Export del schema de desarrollo"
	@echo "  3. Detener servicios de producci√≥n"
	@echo "  4. Eliminar y recrear base de datos"
	@echo "  5. Aplicar schema de desarrollo"
	@echo "  6. Migrar datos existentes (si es posible)"
	@echo "  7. Reiniciar servicios"
	@echo ""
	@echo "$(RED)¬øEst√°s ABSOLUTAMENTE SEGURO? (escribir 'RESTAURAR PRODUCCION'):$(NC)"
	@read CONFIRM && [ "$$CONFIRM" = "RESTAURAR PRODUCCION" ] || (echo "$(GREEN)Operaci√≥n cancelada$(NC)" && exit 1)
	@echo ""
	@echo "$(BLUE)Paso 1/7: Creando backup completo...$(NC)"
	@$(MAKE) -f Makefile.production prod-backup
	@echo "$(GREEN)‚úì Backup creado$(NC)"
	@echo ""
	@echo "$(BLUE)Paso 2/7: Exportando schema de desarrollo...$(NC)"
	@docker exec ai-service-postgres-1 pg_dump -U postgres -d ai_service --schema-only --no-owner --no-privileges > /tmp/dev-schema-restore.sql 2>/dev/null || \
		(echo "$(YELLOW)Desarrollo no activo, usando schema de respaldo...$(NC)" && \
		cp migrations/baseline-schema.sql /tmp/dev-schema-restore.sql)
	@echo "$(GREEN)‚úì Schema exportado$(NC)"
	@echo ""
	@echo "$(BLUE)Paso 3/7: Deteniendo servicios...$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker stop ai-service"
	@echo "$(GREEN)‚úì Servicios detenidos$(NC)"
	@echo ""
	@echo "$(BLUE)Paso 4/7: Recreando base de datos...$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker exec $(PROD_CONTAINER) psql -U $(PROD_DB_USER) -d postgres -c 'DROP DATABASE IF EXISTS $(PROD_DB);'"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker exec $(PROD_CONTAINER) psql -U $(PROD_DB_USER) -d postgres -c 'CREATE DATABASE $(PROD_DB) OWNER $(PROD_DB_USER);'"
	@echo "$(GREEN)‚úì Base de datos recreada$(NC)"
	@echo ""
	@echo "$(BLUE)Paso 5/7: Aplicando schema de desarrollo...$(NC)"
	@$(SCP) /tmp/dev-schema-restore.sql $(PROD_USER)@$(PROD_HOST):/tmp/
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "cat /tmp/dev-schema-restore.sql | sudo /usr/local/bin/docker exec -i $(PROD_CONTAINER) psql -U $(PROD_DB_USER) -d $(PROD_DB)"
	@echo "$(GREEN)‚úì Schema aplicado$(NC)"
	@echo ""
	@echo "$(BLUE)Paso 6/7: Aplicando migraciones pendientes...$(NC)"
	@echo "$(YELLOW)Migraciones incluidas en schema base$(NC)"
	@echo "$(GREEN)‚úì Schema completo aplicado$(NC)"
	@echo ""
	@echo "$(BLUE)Paso 7/7: Reiniciando servicios...$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker start ai-service"
	@sleep 10
	@echo "$(GREEN)‚úì Servicios reiniciados$(NC)"
	@echo ""
	@echo "$(GREEN)‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê$(NC)"
	@echo "$(GREEN)‚úÖ RESTAURACI√ìN COMPLETA$(NC)"
	@echo "$(GREEN)‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê$(NC)"
	@echo ""
	@echo "$(YELLOW)Verificando estado...$(NC)"
	@$(MAKE) -f Makefile.production prod-status

# =============================================================================
# üîÑ PRISMA MIGRATIONS (Database Schema Management)
# =============================================================================

.PHONY: prod-migrate-status
prod-migrate-status: ## Check Prisma migration status in production
	@echo "$(BLUE)üîç Checking migration status in production...$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker exec ai-service sh -c 'DATABASE_URL=postgresql://$(PROD_DB_USER):\$$POSTGRES_PASSWORD@ai-postgres:5432/$(PROD_DB) npx prisma migrate status' 2>&1" || \
	echo "$(YELLOW)‚ö†Ô∏è  If migrations are missing, run: make prod-migrate-deploy$(NC)"

.PHONY: prod-migrate-deploy
prod-migrate-deploy: ## Apply pending Prisma migrations to production (SAFE)
	@echo "$(BLUE)üöÄ Applying Prisma migrations to production...$(NC)"
	@echo "$(YELLOW)This will apply all pending migrations from prisma/migrations$(NC)"
	@echo "$(YELLOW)Continue? (y/N):$(NC)"
	@read CONFIRM && [ "$$CONFIRM" = "y" ] || (echo "$(GREEN)Cancelled$(NC)" && exit 1)
	@echo "$(BLUE)Creating backup first...$(NC)"
	@$(MAKE) -f Makefile.production prod-backup
	@echo "$(BLUE)Applying migrations...$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker exec ai-service sh -c 'DATABASE_URL=postgresql://$(PROD_DB_USER):\$$POSTGRES_PASSWORD@ai-postgres:5432/$(PROD_DB) npx prisma migrate deploy' 2>&1" && \
	echo "$(GREEN)‚úÖ Migrations applied successfully!$(NC)" || \
	(echo "$(RED)‚ùå Migration failed! Check logs above$(NC)" && exit 1)
	@echo "$(BLUE)Verifying schema...$(NC)"
	@$(MAKE) -f Makefile.production prod-check-db

.PHONY: prod-migrate-reset
prod-migrate-reset: ## DANGER: Reset database and apply all migrations from scratch
	@echo "$(RED)‚ö†Ô∏è  WARNING: This will DELETE ALL DATA and recreate the schema!$(NC)"
	@echo "$(RED)Host: $(PROD_HOST)$(NC)"
	@echo "$(RED)Database: $(PROD_DB)$(NC)"
	@echo "$(YELLOW)Type 'RESET DATABASE' to continue:$(NC)"
	@read CONFIRM && [ "$$CONFIRM" = "RESET DATABASE" ] || (echo "$(GREEN)Cancelled$(NC)" && exit 1)
	@echo "$(BLUE)Creating final backup...$(NC)"
	@$(MAKE) -f Makefile.production prod-backup
	@echo "$(RED)Resetting database...$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker exec ai-service sh -c 'DATABASE_URL=postgresql://$(PROD_DB_USER):\$$POSTGRES_PASSWORD@ai-postgres:5432/$(PROD_DB) npx prisma migrate reset --force' 2>&1" && \
	echo "$(GREEN)‚úÖ Database reset and migrations applied!$(NC)" || \
	(echo "$(RED)‚ùå Reset failed!$(NC)" && exit 1)

.PHONY: prod-migrate-create
prod-migrate-create: ## Create a new migration from local development
	@echo "$(BLUE)üìù Creating new migration from current schema...$(NC)"
	@read -p "Enter migration name (e.g., add_new_field): " NAME; \
	if [ -z "$$NAME" ]; then \
		echo "$(RED)‚ùå Migration name is required$(NC)"; \
		exit 1; \
	fi; \
	npx prisma migrate dev --name $$NAME --create-only && \
	echo "$(GREEN)‚úÖ Migration created: prisma/migrations/*_$$NAME$(NC)" && \
	echo "$(YELLOW)Review the migration, then run 'make prod-migrate-deploy' to apply$(NC)"

.PHONY: prod-prisma-generate
prod-prisma-generate: ## Generate Prisma client in production container
	@echo "$(BLUE)üîß Generating Prisma client in production...$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker exec ai-service npx prisma generate" && \
	echo "$(GREEN)‚úÖ Prisma client generated$(NC)" || \
	echo "$(RED)‚ùå Failed to generate Prisma client$(NC)"

# =============================================================================
# üîê TEST DE AUTENTICACI√ìN
# =============================================================================

.PHONY: test-auth
test-auth: ## Test authentication (SSH and sudo)
	@echo "$(BLUE)üîê Testing authentication...$(NC)"
	@echo "1. Checking variables are defined:"
	@echo "   SSHPASS: $$([ -n '$(SSHPASS)' ] && echo '‚úì Defined' || echo '‚úó Not defined')"
	@echo "   SUDO_PASS: $$([ -n '$(SUDO_PASS)' ] && echo '‚úì Defined' || echo '‚úó Not defined')"
	@echo ""
	@echo "2. Testing SSH connection:"
	@SSHPASS='$(SSHPASS)' sshpass -e ssh -o StrictHostKeyChecking=no $(PROD_USER)@$(PROD_HOST) "echo '   ‚úì SSH connection successful'" || echo "   ‚úó SSH failed"
	@echo ""
	@echo "3. Testing sudo with password:"
	@SSHPASS='$(SSHPASS)' sshpass -e ssh -o StrictHostKeyChecking=no $(PROD_USER)@$(PROD_HOST) "sudo echo '   ‚úì Sudo authentication successful'" || echo "   ‚úó Sudo failed"

# =============================================================================
# üîë COMANDOS DE PRODUCCI√ìN - Authentication Management
# =============================================================================

.PHONY: prod-auth-create-admin
prod-auth-create-admin: ## Crear usuario admin (admin@ai-service.local / admin123)
	@echo "$(BLUE)üë§ Creating admin user in production...$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker exec $(PROD_CONTAINER) psql -U $(PROD_DB_USER) -d $(PROD_DB) -c \"INSERT INTO users (email, password_hash, full_name, role) VALUES ('admin@ai-service.local', '\\\$$2b\\\$$10\\\$$8YzH7X1vKpFdKjb8rqOAOe8uEpZ4UjQn9mGxK7bgQqFvI9o1aWVKq', 'System Administrator', 'admin') ON CONFLICT (email) DO UPDATE SET password_hash = EXCLUDED.password_hash;\" 2>/dev/null" && \
	echo "$(GREEN)‚úÖ Admin user created/updated$(NC)" && \
	echo "üìß Email: admin@ai-service.local" && \
	echo "üîë Password: admin123" || \
	echo "$(RED)‚ùå Failed to create admin user$(NC)"

.PHONY: prod-auth-list-users
prod-auth-list-users: ## Listar todos los usuarios en producci√≥n
	@echo "$(BLUE)üìã Listing production users...$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker exec $(PROD_CONTAINER) psql -U $(PROD_DB_USER) -d $(PROD_DB) -c \"SELECT email, full_name, role, is_active, created_at FROM users ORDER BY created_at DESC;\" 2>/dev/null" || \
	echo "$(RED)‚ùå Could not list users. Check if auth tables exist.$(NC)"

.PHONY: prod-auth-reset-attempts
prod-auth-reset-attempts: ## Limpiar todos los intentos de login en producci√≥n
	@echo "$(YELLOW)üîì Resetting login attempts in production...$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker exec $(PROD_CONTAINER) psql -U $(PROD_DB_USER) -d $(PROD_DB) -c \"DELETE FROM login_attempts;\" 2>/dev/null" && \
	echo "$(GREEN)‚úÖ Login attempts cleared$(NC)" || \
	echo "$(RED)‚ùå Could not reset attempts. Check if auth tables exist.$(NC)"

.PHONY: prod-auth-check-attempts
prod-auth-check-attempts: ## Ver intentos recientes de login en producci√≥n
	@echo "$(BLUE)üîç Checking recent login attempts in production...$(NC)"
	@$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker exec $(PROD_CONTAINER) psql -U $(PROD_DB_USER) -d $(PROD_DB) -c \"SELECT email, ip_address, success, attempted_at FROM login_attempts ORDER BY attempted_at DESC LIMIT 20;\" 2>/dev/null" || \
	echo "$(RED)‚ùå Could not check attempts. Check if auth tables exist.$(NC)"

.PHONY: prod-auth-reset-password
prod-auth-reset-password: ## Resetear contrase√±a de usuario en producci√≥n (interactivo)
	@echo "$(BLUE)üîë Reset user password in production$(NC)"
	@read -p "Enter email: " email; \
	read -s -p "Enter new password: " password; \
	echo; \
	if [ -z "$$email" ] || [ -z "$$password" ]; then \
		echo "$(RED)‚ùå Email and password are required$(NC)"; \
		exit 1; \
	fi; \
	HASH=$$(docker run --rm node:20-alpine sh -c "npm install bcrypt && node -e \"const bcrypt = require('bcrypt'); bcrypt.hash('$$password', 10).then(h => console.log(h))\"" 2>/dev/null | tail -1); \
	if [ -z "$$HASH" ]; then \
		echo "$(RED)‚ùå Failed to generate password hash$(NC)"; \
		exit 1; \
	fi; \
	$(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker exec $(PROD_CONTAINER) psql -U $(PROD_DB_USER) -d $(PROD_DB) -c \"UPDATE users SET password_hash = '$$HASH' WHERE email = '$$email' RETURNING email;\" 2>/dev/null" | grep -q "1 row" && \
	echo "$(GREEN)‚úÖ Password updated for $$email$(NC)" || \
	echo "$(RED)‚ùå User not found or update failed$(NC)"

.PHONY: prod-auth-check-tables
prod-auth-check-tables: ## Verificar si existen las tablas de autenticaci√≥n
	@echo "$(BLUE)üîç Checking auth tables in production...$(NC)"
	@TABLES=$$($(SSH) $(PROD_USER)@$(PROD_HOST) "sudo /usr/local/bin/docker exec $(PROD_CONTAINER) psql -U $(PROD_DB_USER) -d $(PROD_DB) -t -c \"SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_name IN ('users', 'refresh_tokens', 'login_attempts');\" 2>/dev/null" | tr -d ' \n'); \
	if [ -z "$$TABLES" ]; then \
		echo "$(RED)‚ùå Auth tables not found$(NC)"; \
		echo "$(YELLOW)Run 'make prod-sql-file FILE=migrations/006-minimal-auth-tables.sql' to create them$(NC)"; \
	else \
		echo "$(GREEN)‚úÖ Auth tables found: $$TABLES$(NC)"; \
	fi

# =============================================================================
# Ayuda
# =============================================================================

.PHONY: help
help: ## Mostrar esta ayuda
	@echo "$(RED)‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó$(NC)"
	@echo "$(RED)‚ïë          COMANDOS DE PRODUCCI√ìN - USAR CON CUIDADO           ‚ïë$(NC)"
	@echo "$(RED)‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù$(NC)"
	@echo ""
	@grep -E '^[a-zA-Z_-]+:.*?## .*$$' $(MAKEFILE_LIST) | awk 'BEGIN {FS = ":.*?## "}; {printf "$(YELLOW)%-20s$(NC) %s\n", $$1, $$2}'
	@echo ""
	@echo "$(RED)‚ö†Ô∏è  ADVERTENCIA: Estos comandos afectan el ambiente de PRODUCCI√ìN$(NC)"

.DEFAULT_GOAL := help