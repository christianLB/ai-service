import { createExpressEndpoints } from '@ts-rest/express';
import { Express } from 'express';
import { {{camelCase model}}Contract } from '../../packages/contracts/src/contracts/{{kebabCase model}}';
import { {{pascalCase model}}Service } from '../services{{#if schema}}/{{schema}}{{/if}}/{{kebabCase model}}.service';
import { logger } from '../utils/log';
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();
const service = new {{pascalCase model}}Service(prisma);

export function setup{{pascalCase model}}Routes(app: Express) {
  createExpressEndpoints({{camelCase model}}Contract, {
    // Get all {{lowerCase model}}s
    getAll: async ({ query }) => {
      try {
        const { page = 1, limit = 20, sortBy, sortOrder, search, include, ...filters } = query;
        
        const result = await service.findAll({
          page,
          limit,
          sortBy,
          sortOrder,
          search,
          include,
          filters,
        });

        return {
          status: 200,
          body: {
            success: true,
            data: result.data,
            pagination: {
              total: result.total,
              page,
              limit,
              totalPages: Math.ceil(result.total / limit),
            },
          },
        };
      } catch (error) {
        logger.error('Error fetching {{lowerCase model}}s:', error);
        return {
          status: 500,
          body: {
            success: false,
            error: 'Failed to fetch {{lowerCase model}}s',
          },
        };
      }
    },

    // Get {{lowerCase model}} by ID
    getById: async ({ params, query }) => {
      try {
        const result = await service.findById(params.id, query?.include);
        
        if (!result) {
          return {
            status: 404,
            body: {
              success: false,
              error: '{{pascalCase model}} not found',
            },
          };
        }

        return {
          status: 200,
          body: {
            success: true,
            data: result,
          },
        };
      } catch (error) {
        logger.error('Error fetching {{lowerCase model}}:', error);
        return {
          status: 500,
          body: {
            success: false,
            error: 'Failed to fetch {{lowerCase model}}',
          },
        };
      }
    },

    // Create new {{lowerCase model}}
    create: async ({ body }) => {
      try {
        const result = await service.create(body);

        return {
          status: 201,
          body: {
            success: true,
            data: result,
          },
        };
      } catch (error: any) {
        logger.error('Error creating {{lowerCase model}}:', error);
        
        if (error.code === 'P2002') {
          return {
            status: 400,
            body: {
              success: false,
              error: 'A {{lowerCase model}} with this data already exists',
            },
          };
        }

        if (error.name === 'ValidationError' || error.code === 'P2003') {
          return {
            status: 400,
            body: {
              success: false,
              error: error.message || 'Validation failed',
            },
          };
        }

        return {
          status: 500,
          body: {
            success: false,
            error: 'Failed to create {{lowerCase model}}',
          },
        };
      }
    },

    // Update {{lowerCase model}}
    update: async ({ params, body }) => {
      try {
        const result = await service.update(params.id, body);

        if (!result) {
          return {
            status: 404,
            body: {
              success: false,
              error: '{{pascalCase model}} not found',
            },
          };
        }

        return {
          status: 200,
          body: {
            success: true,
            data: result,
          },
        };
      } catch (error: any) {
        logger.error('Error updating {{lowerCase model}}:', error);

        if (error.code === 'P2002') {
          return {
            status: 400,
            body: {
              success: false,
              error: 'A {{lowerCase model}} with this data already exists',
            },
          };
        }

        if (error.name === 'ValidationError' || error.code === 'P2003') {
          return {
            status: 400,
            body: {
              success: false,
              error: error.message || 'Validation failed',
            },
          };
        }

        return {
          status: 500,
          body: {
            success: false,
            error: 'Failed to update {{lowerCase model}}',
          },
        };
      }
    },

    // Delete {{lowerCase model}}
    delete: async ({ params }) => {
      try {
        const success = await service.delete(params.id);

        if (!success) {
          return {
            status: 404,
            body: {
              success: false,
              error: '{{pascalCase model}} not found',
            },
          };
        }

        return {
          status: 200,
          body: {
            success: true,
            message: '{{pascalCase model}} deleted successfully',
          },
        };
      } catch (error: any) {
        logger.error('Error deleting {{lowerCase model}}:', error);

        if (error.code === 'P2003') {
          return {
            status: 400,
            body: {
              success: false,
              error: 'Cannot delete {{lowerCase model}} due to existing references',
            },
          };
        }

        return {
          status: 500,
          body: {
            success: false,
            error: 'Failed to delete {{lowerCase model}}',
          },
        };
      }
    },

    {{#if hasBulkOperations}}
    // Bulk create {{lowerCase model}}s
    bulkCreate: async ({ body }) => {
      try {
        const result = await service.bulkCreate(body.data);

        return {
          status: 201,
          body: {
            success: true,
            data: result,
            count: result.length,
          },
        };
      } catch (error) {
        logger.error('Error bulk creating {{lowerCase model}}s:', error);
        return {
          status: 500,
          body: {
            success: false,
            error: 'Failed to bulk create {{lowerCase model}}s',
          },
        };
      }
    },

    // Bulk update {{lowerCase model}}s
    bulkUpdate: async ({ body }) => {
      try {
        const count = await service.bulkUpdate(body.where, body.data);

        return {
          status: 200,
          body: {
            success: true,
            count,
          },
        };
      } catch (error) {
        logger.error('Error bulk updating {{lowerCase model}}s:', error);
        return {
          status: 500,
          body: {
            success: false,
            error: 'Failed to bulk update {{lowerCase model}}s',
          },
        };
      }
    },

    // Bulk delete {{lowerCase model}}s
    bulkDelete: async ({ body }) => {
      try {
        const count = await service.bulkDelete(body.ids);

        return {
          status: 200,
          body: {
            success: true,
            count,
          },
        };
      } catch (error) {
        logger.error('Error bulk deleting {{lowerCase model}}s:', error);
        return {
          status: 500,
          body: {
            success: false,
            error: 'Failed to bulk delete {{lowerCase model}}s',
          },
        };
      }
    },
    {{/if}}
  }, app);

  logger.info('{{pascalCase model}} routes initialized with ts-rest');
}